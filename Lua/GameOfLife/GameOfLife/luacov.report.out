==============================================================================
.\FrameMaker.lua
==============================================================================

    2 Frame = require "entity.Frame"
    2 FileInputHandler = require ("input.FileInputHandler").getInstance()
    2 local read = io.read

    2 local FrameMaker = {}

    2 function FrameMaker:getInstance()

    4     local instance = {}

          local createFrame = function()

   14         local frame = {}

   14         print("Do you want to load the map from a file? Y - Yes\t N - No")

   14         if(string.upper(read()) == "Y" ) then
   10             frame = instance.loadFromFile(frame)
              else
    4             frame = instance.createIndividual(frame)
              end

   14         frame.duration = instance.getValue("How many generations do you want to simulate?")

   14         return frame
          end

          instance.createIndividual = function(frame)
    4         print("\nI - Individual settings\t G - General settings")

    4         if(string.upper(read()) == "G")
              then
    4             frame = Frame(
    2                 instance.getValue("Please enter the width of the testframe (integer value):"),  -- Frame height
    2                 instance.getValue("Please enter the height of the testframe (integer value):")  -- Frame width
    2             )
              else
    4             frame = Frame(
    2                 instance.getValue("Please enter the width of the testframe (integer value):"),   -- Frame height
    2                 instance.getValue("Please enter the height of the testframe (integer value):"), -- Frame width
    2                 instance.getValue("Please enter the elapsed time between two generations (in millisec)!"),  -- timeBetweenGens
    2                 instance.getValue("Please enter the rate of the living cells - (1 / rate) will be the chance - (choose at least 2)!")   --chance
    2             )
              end

    4         return frame
          end

          instance.getValue = function(msg)
   26         local correct = false
              local value

   52         while(correct ~= true) do

   26             print("\n"..msg.."\t")
   26             value = tonumber(read())
   26             if(type(value) == type(0)) then
   26                 correct = true
                  else
****0                 print("Type error! Please use integer value!")
                  end
              end

   26         return value
          end

          instance.loadFromFile = function(frame)

   10         print("\nDo you want to load a pre-defined map? Y - Yes\t N - No")
   10         print("*Note: If you run this app in command promt please make sure that you are in the root directory of the game!*")

   10         if(string.upper(read()) == "Y") then
   10             print("\nPlease enter the name of the pre-defined map (only the name - no extension - )!")
   10             frame = FileInputHandler.createFrameFromFile(read())

              else
****0             print("\nPlease enter the absolute path of the test map!")
****0             frame = FileInputHandler.createFrameFromFile(read(), false)
              end

   10         return frame

          end

    4     return {
    4         createFrame = createFrame
    4     }
      end

    2 return FrameMaker


==============================================================================
.\entity\Cell.lua
==============================================================================

    2 StateType = require "type.StateType"
    2 ChangeType = require "type.ChangeType"

    2 local Cell = {
    2     state = "",
    2     changeState = 0
      }

    4 setmetatable(Cell, {
          __call = function(class, ...)
 1586         return class:CreateCell(...)
          end
      })

    2 function Cell:CreateCell(state)
 1586     local newCell = setmetatable({}, self)
 1586     self.__index = self
 1586     newCell.state = state
 1586     newCell.neighbors = {}
 1586     return newCell
      end

    2 function Cell:checkState()
  414     local livingNeighbors = 0

 3588     for _, cell in ipairs(self.neighbors) do
 3174         if(cell.state == StateType.ALIVE) then
 1052             livingNeighbors = livingNeighbors + 1
              end
          end

  414     if(livingNeighbors > 3 or livingNeighbors < 2) then
  278         if(self.state == StateType.ALIVE) then
   98             self.changeState = ChangeType.DIE
              else
  180             self.changeState = ChangeType.NOTHING
              end
          else
  136         if(self.state == StateType.DEAD and livingNeighbors == 3) then
   24             self.changeState = ChangeType.BIRTH
              else
  112             self.changeState = ChangeType.NOTHING
              end
          end

      end

    2 function Cell:die()
  396     if(self.changeState == ChangeType.DIE) then
   96         self.state = StateType.DEAD
          end
      end

    2 function Cell:birth()
  394     if(self.changeState == ChangeType.BIRTH) then
   22         self.state = StateType.ALIVE
          end
      end

    2 return Cell

==============================================================================
.\entity\Frame.lua
==============================================================================

    2 local Cell = require "entity.Cell"
    2 local StateType = require "type.StateType"

    2 local Frame = {
    2     generationCounter = 0,
    2     duration = 100,
      }

    4 setmetatable(Frame, {
          __call = function(class, ...)
   14         return class:CreateFrame(...)
          end
      })

    2 function Frame:CreateFrame(height, width, timeBetweenGens, chance)
   14     local newFrame = setmetatable({}, self)
   14     self.__index = self
   14     newFrame.height = height or 20
   14     newFrame.width = width or 20
   14     newFrame.timeBetweenGens = timeBetweenGens or 400.0
   14     newFrame.chance =  chance or 4
   14     newFrame.cells = {}

   14     newFrame:init()

   14     return newFrame
      end

    2 function Frame:init()

  150     for i = 1, self.height, 1 do
  136         table.insert(self.cells, {})
          end

   14     local chanceGen = self.chance
   14     if(2 > chanceGen) then
****0         chanceGen = 4
          end

   14     math.randomseed(os.time())
  150     for i = 1, self.height, 1 do

 1652         for j = 1, self.width, 1 do

 1516             local isAlive = (math.random(100000) % chanceGen) == 0

 1516             local cellState = StateType.ALIVE

 1516             if(isAlive == false) then
 1129                 cellState = StateType.DEAD
                  end

 1516             table.insert(self.cells[i], Cell(cellState))
              end
          end

   14     self:createNeighbors()

      end

    2 function Frame:createNeighbors()
  150     for i = 1, self.height, 1 do
 1652         for j = 1, self.width, 1 do

                  local upperRow
                  local lowerRow
                  local upperColumn
                  local lowerColumn
 1516             if(i - 1 == 0) then upperRow = self.height else upperRow = i - 1 end
 1516             if(i + 1 == self.height + 1) then lowerRow = 1 else lowerRow = i + 1 end
 1516             if(j - 1 == 0) then upperColumn = self.width else upperColumn = j - 1 end
 1516             if(j + 1 == self.width + 1) then lowerColumn = 1 else lowerColumn = j + 1 end

 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[upperRow][upperColumn]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[upperRow][j]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[upperRow][lowerColumn]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[i]       [upperColumn]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[i]       [lowerColumn]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[lowerRow][upperColumn]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[lowerRow][j]
 1516             self.cells[i][j].neighbors[#self.cells[i][j].neighbors + 1] = self.cells[lowerRow][lowerColumn]

              end
          end
      end

    2 function Frame:simulate()

****0     self:printResult()

****0     while(self.generationCounter < self.duration) do
****0         self:wait(self.timeBetweenGens / 1000)
****0         self:createNextGen()
          end

      end

    2 function Frame:createNextGen()

   12     self:markToDie()
   12     self:cellsBirth()
   12     self:cellsDie()

   12     self.generationCounter = self.generationCounter + 1

   12     self:printResult()
      end

    2 function Frame:getLivingCount()
   34     local livingCount = 0
  226     for i = 1, self.height, 1 do
 1284         for j = 1, self.width, 1 do
 1092             if(self.cells[i][j].state == StateType.ALIVE) then
  216                 livingCount = livingCount + 1
                  end
              end
          end
   34     return livingCount

      end

    2 function Frame:markToDie()
   80     for i = 1, self.height, 1 do
  456         for j = 1, self.width, 1 do
  388             self.cells[i][j]:checkState()
              end
          end

      end

    2 function Frame:cellsDie()
   80     for i = 1, self.height, 1 do
  456         for j = 1, self.width, 1 do
  388             self.cells[i][j]:die()
              end
          end
      end

    2 function Frame:cellsBirth()
   80     for i = 1, self.height, 1 do
  456         for j = 1, self.width, 1 do
  388             self.cells[i][j]:birth()
              end
          end
      end

    2 function Frame:printResult()
   12     os.execute("cls")
   12     print("Generation:".. self.generationCounter .."\tNumber of living cells: ".. self:getLivingCount() .."\n")
   80     for i = 1, self.height, 1 do
   68         io.flush()
  456         for j = 1, self.width, 1 do
  388             if(self.cells[i][j].state == StateType.ALIVE) then
   52                 io.write("#")
                  else
  336                 io.write(" ")
                  end
              end
   68         print()
          end
   12     print()

      end


    2 function Frame:wait(seconds)
****0     local time = os.clock()
****0     while os.clock()-time < seconds do  end
      end

    2 return Frame

==============================================================================
.\input\FileInputHandler.lua
==============================================================================

    2 local FileInputHandler = {}


    2 function FileInputHandler:getInstance()

    2     local instance = {}

          local createFrameFromFile = function(fileName, relative)

   10         instance.fileName = fileName
   10         instance.relative = relative or true
   10         instance.lines = {}

   10         if(instance.file_exists() == false) then return error("file not found.") end

   10         instance.lines = instance.getLines()


   10         local firstLine = instance.split(instance.lines[1], " ")

   10         local error = assert( #firstLine == 3, "The context of the file is incorrect! PLease make sure to give a correct matrix definition!")
   10         if(type(error) == string) then
****0             print(error)
              end

   10         error = assert( #instance.lines - 1 == tonumber(firstLine[1]), "The context of the file is incorrect! PLease make sure that the number of rows is correct!")
   10         if(type(error) == string) then
****0             print(error)
              end

   66         for i = 2, #instance.lines, 1 do
   56             error = assert(#instance.lines[i] == tonumber(firstLine[2]), "The context of the file is incorrect! PLease make sure that the number of columns is correct!")
   56             if(type(error) == string) then
****0                 print(error)
                  end
              end

   10         local aliveCellType = firstLine[3]

   10         local frame = Frame(tonumber(firstLine[1]), tonumber(firstLine[2]))

   66         for i = 1, frame.height, 1 do
  372             for j = 1, frame.width, 1 do
  316                 local state = StateType.DEAD

  316                 if(string.sub(instance.lines[i + 1],j,j) == aliveCellType) then
  112                     state = StateType.ALIVE
                      end

  316                 frame.cells[i][j].state = state
                  end
              end

   10         return frame
          end

          instance.split = function(s, delimiter)
   10         local result = {};
   40         for match in (s..delimiter):gmatch("(.-)"..delimiter) do
   30             table.insert(result, match);
              end
   10         return result;
          end

          instance.getLines = function()

   10         if(instance.relative) then
   10             instance.fileName = "testMaps/".. instance.fileName ..".txt"
              end

   10         local lines = {}
   76         for line in io.lines(instance.fileName) do
   66             lines[#lines + 1] = line
              end

   10         return lines
          end

          instance.file_exists = function()
              local result
   10         if(instance.relative) then
   10             result = assert(io.open("testMaps/".. instance.fileName ..".txt", "r"), "File not found!")
              else
****0             result = assert(io.open(instance.fileName , "r"), "File not found!")
              end

   10         if( type(result) == type(" ")) then
****0             print(result)
****0             return false
              else
   10             result:close()
   10             return true
              end
          end


    2     return {
    2         createFrameFromFile = createFrameFromFile
    2     }

      end

    2 return FileInputHandler

==============================================================================
.\test\cellUnitTest.lua
==============================================================================

    2 local Cell = require "entity.Cell"
    2 local StateType = require "type.StateType"
    2 local ChangeType = require "type.ChangeType"

    2 function testStateWithTwoNeighborsAlive()

****0     local cell = Cell(StateType.ALIVE)

****0     table.insert(cell.neighbors, Cell(StateType.ALIVE))
****0     table.insert(cell.neighbors, Cell(StateType.ALIVE))

****0     cell:checkState()

****0     lu.assertEquals(cell.changeState, ChangeType.NOTHING)

****0     cell.state = StateType.DEAD

****0     cell:checkState()

****0     lu.assertEquals(cell.changeState, ChangeType.NOTHING)
      end

    2 function testStateWithThreeNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.NOTHING)

    2     cell.state = StateType.DEAD

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.BIRTH)
      end

    2 function testStateWithTwoNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.NOTHING)

    2     cell.state = StateType.DEAD

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.NOTHING)
      end

    2 function testStateWithLessThanTwoNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.DIE)

    2     cell.state = StateType.DEAD

    2     cell:checkState()

    2     lu.assertEquals(cell.changeState, ChangeType.NOTHING)
      end

    2 function testBirthWithTwoNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.DEAD))

    2     cell.state = StateType.DEAD

    2     cell:checkState()
    2     cell:birth()

    2     lu.assertEquals(cell.state, StateType.DEAD)
      end

    2 function testBirthWithThreeNeighborsAlive()

    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell.state = StateType.DEAD

    2     cell:checkState()
    2     cell:birth()

    2     lu.assertEquals(cell.state, StateType.ALIVE)
      end

    2 function testBirthWithMoreThanThreeNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell.state = StateType.DEAD

    2     cell:checkState()
    2     cell:birth()

    2     lu.assertEquals(cell.state, StateType.DEAD)
      end

    2 function testDieWithLessThanTwoNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.DEAD))
    2     table.insert(cell.neighbors, Cell(StateType.DEAD))

    2     cell.state = StateType.ALIVE

    2     cell:checkState()
    2     cell:die()

    2     lu.assertEquals(cell.state, StateType.DEAD)
      end

    2 function testDieWithTwoOrThreeNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.DEAD))

    2     cell.state = StateType.ALIVE

    2     cell:checkState()
    2     cell:die()

    2     lu.assertEquals(cell.state, StateType.ALIVE)

    2     cell.neighbors[2].state = StateType.ALIVE

    2     cell:checkState()
    2     cell:die()

    2     lu.assertEquals(cell.state, StateType.ALIVE)
      end

    2 function testDieWithMoreThanThreeNeighborsAlive()
    2     local cell = Cell(StateType.ALIVE)

    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))
    2     table.insert(cell.neighbors, Cell(StateType.ALIVE))

    2     cell.state = StateType.ALIVE

    2     cell:checkState()
    2     cell:die()

    2     lu.assertEquals(cell.state, StateType.DEAD)
      end

==============================================================================
.\test\frameMakerUnitTest.lua
==============================================================================


    2 h = require "test.testHelper"
    2 io.read = h.read

    2 local FrameMaker = require("FrameMaker").getInstance()

    2 function testCreateFrameFromFile()

    2     h.input = {"y", "y", "blinker", 2}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame.height, 5)
    2     lu.assertEquals(frame.width, 5)
    2     lu.assertEquals(frame:getLivingCount(), 3)
      end


    2 function testCreateGeneralFrame()

    2     h.input = {"n", "g", 20, 15, 2}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame.height, 20)
    2     lu.assertEquals(frame.width, 15)
    2     lu.assertEquals(frame.timeBetweenGens, 400)
    2     lu.assertEquals(frame.chance, 4)
      end



    2 function testCreateIndividual()

    2     h.input = {"n", "i", 20, 15, 300, 3, 2}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame.height, 20)
    2     lu.assertEquals(frame.width, 15)
    2     lu.assertEquals(frame.timeBetweenGens, 300)
    2     lu.assertEquals(frame.chance, 3)
      end

      --io.read = old


==============================================================================
.\test\frameTest.lua
==============================================================================

    2 h = require "test.testHelper"
    2 io.read = h.read

    2 local FrameMaker = require("FrameMaker").getInstance()
    2 local StateType = require "type.StateType"

    2 function testCheckNextGenForBeacon()

    2     h.input = {"y", "y", "beacon", 0}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame:getLivingCount(), 8)

    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][4].state, StateType.ALIVE)

    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 6)

    2     lu.assertEquals(frame.cells[3][3].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[4][4].state, StateType.DEAD)

    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 8)

    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][4].state, StateType.ALIVE)
      end


    2 function testCheckNextGenForBlinker()

    2     h.input = {"y", "y", "blinker", 0}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame:getLivingCount(), 3)

    2     lu.assertEquals(frame.cells[3][2].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][4].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[2][3].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[4][3].state, StateType.DEAD)

    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 3)

    2     lu.assertEquals(frame.cells[3][2].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][4].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[2][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][3].state, StateType.ALIVE)

    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 3)

    2     lu.assertEquals(frame.cells[3][2].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][4].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[2][3].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[4][3].state, StateType.DEAD)
      end


    2 function testCheckNextGenForFullHouse()

    2     h.input = {"y", "y", "fullhouse", 0}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame:getLivingCount(), 36)

    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 0)

      end


    2 function testCheckNextGenForToad()
    2     h.input = {"y", "y", "toad", 0}
    2     h.cnt = 0

    2     local frame = FrameMaker.createFrame()

    2     lu.assertEquals(frame:getLivingCount(), 6)

    2     lu.assertEquals(frame.cells[2][4].state, StateType.DEAD)

    2     lu.assertEquals(frame.cells[3][2].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[3][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][4].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][5].state, StateType.ALIVE)

    2     lu.assertEquals(frame.cells[4][2].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][3].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][4].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][5].state, StateType.DEAD)

    2     lu.assertEquals(frame.cells[5][3].state, StateType.DEAD)


    2     frame:createNextGen()

    2     lu.assertEquals(frame:getLivingCount(), 6)

    2     lu.assertEquals(frame.cells[2][4].state, StateType.ALIVE)

    2     lu.assertEquals(frame.cells[3][2].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[3][3].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[3][4].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[3][5].state, StateType.ALIVE)

    2     lu.assertEquals(frame.cells[4][2].state, StateType.ALIVE)
    2     lu.assertEquals(frame.cells[4][3].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[4][4].state, StateType.DEAD)
    2     lu.assertEquals(frame.cells[4][5].state, StateType.ALIVE)

    2     lu.assertEquals(frame.cells[5][3].state, StateType.ALIVE)
      end

    2 io.read = old

==============================================================================
.\test\luaunit.lua
==============================================================================
      --[[
              luaunit.lua

      Description: A unit testing framework
      Homepage: https://github.com/bluebird75/luaunit
      Development by Philippe Fremy <phil@freehackers.org>
      Based on initial work of Ryu, Gwang (http://www.gpgstudy.com/gpgiki/LuaUnit)
      License: BSD License, see LICENSE.txt
      ]]--

    2 require("math")
    2 local M={}

      -- private exported functions (for testing)
    2 M.private = {}

    2 M.VERSION='3.3'
    2 M._VERSION=M.VERSION -- For LuaUnit v2 compatibility

      -- a version which distinguish between regular Lua and LuaJit
    2 M._LUAVERSION = (jit and jit.version) or _VERSION

      --[[ Some people like assertEquals( actual, expected ) and some people prefer
      assertEquals( expected, actual ).
      ]]--
    2 M.ORDER_ACTUAL_EXPECTED = true
    2 M.PRINT_TABLE_REF_IN_ERROR_MSG = false
    2 M.TABLE_EQUALS_KEYBYCONTENT = true
    2 M.LINE_LENGTH = 80
    2 M.TABLE_DIFF_ANALYSIS_THRESHOLD = 10    -- display deep analysis for more than 10 items
    2 M.LIST_DIFF_ANALYSIS_THRESHOLD  = 10    -- display deep analysis for more than 10 items

      --[[ EPS is meant to help with Lua's floating point math in simple corner
      cases like almostEquals(1.1-0.1, 1), which may not work as-is (e.g. on numbers
      with rational binary representation) if the user doesn't provide some explicit
      error margin.

      The default margin used by almostEquals() in such cases is EPS; and since
      Lua may be compiled with different numeric precisions (single vs. double), we
      try to select a useful default for it dynamically. Note: If the initial value
      is not acceptable, it can be changed by the user to better suit specific needs.

      See also: https://en.wikipedia.org/wiki/Machine_epsilon
      ]]
    2 M.EPS = 2^-52 -- = machine epsilon for "double", ~2.22E-16
    2 if math.abs(1.1 - 1 - 0.1) > M.EPS then
          -- rounding error is above EPS, assume single precision
****0     M.EPS = 2^-23 -- = machine epsilon for "float", ~1.19E-07
      end

      -- set this to false to debug luaunit
    2 local STRIP_LUAUNIT_FROM_STACKTRACE = true

    2 M.VERBOSITY_DEFAULT = 10
    2 M.VERBOSITY_LOW     = 1
    2 M.VERBOSITY_QUIET   = 0
    2 M.VERBOSITY_VERBOSE = 20
    2 M.DEFAULT_DEEP_ANALYSIS = nil
    2 M.FORCE_DEEP_ANALYSIS   = true
    2 M.DISABLE_DEEP_ANALYSIS = false

      -- set EXPORT_ASSERT_TO_GLOBALS to have all asserts visible as global values
      -- EXPORT_ASSERT_TO_GLOBALS = true

      -- we need to keep a copy of the script args before it is overriden
    2 local cmdline_argv = rawget(_G, "arg")

    2 M.FAILURE_PREFIX = 'LuaUnit test FAILURE: ' -- prefix string for failed tests
    2 M.SUCCESS_PREFIX = 'LuaUnit test SUCCESS: ' -- prefix string for successful tests finished early



      M.USAGE=[[Usage: lua <your_test_suite.lua> [options] [testname1 [testname2] ... ]
      Options:
        -h, --help:             Print this help
        --version:              Print version information
        -v, --verbose:          Increase verbosity
        -q, --quiet:            Set verbosity to minimum
        -e, --error:            Stop on first error
        -f, --failure:          Stop on first failure or error
        -s, --shuffle:          Shuffle tests before running them
        -o, --output OUTPUT:    Set output type to OUTPUT
                                Possible values: text, tap, junit, nil
        -n, --name NAME:        For junit only, mandatory name of xml file
        -r, --repeat NUM:       Execute all tests NUM times, e.g. to trig the JIT
        -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN
                                May be repeated to include several patterns
                                Make sure you escape magic chars like +? with %
        -x, --exclude PATTERN:  Exclude all test names matching the Lua PATTERN
                                May be repeated to exclude several patterns
                                Make sure you escape magic chars like +? with %
        testname1, testname2, ... : tests to run in the form of testFunction,
                                    TestClass or TestClass.testMethod
    2 ]]

      local is_equal -- defined here to allow calling from mismatchFormattingPureList

      ----------------------------------------------------------------
      --
      --                 general utility functions
      --
      ----------------------------------------------------------------

      local function pcall_or_abort(func, ...)
          -- unpack is a global function for Lua 5.1, otherwise use table.unpack
    2     local unpack = rawget(_G, "unpack") or table.unpack
    2     local result = {pcall(func, ...)}
    2     if not result[1] then
              -- an error occurred
****0         print(result[2]) -- error message
****0         print()
****0         print(M.USAGE)
****0         os.exit(-1)
          end
    2     return unpack(result, 2)
      end

    2 local crossTypeOrdering = {
    2     number = 1, boolean = 2, string = 3, table = 4, other = 5
      }
    2 local crossTypeComparison = {
    2     number = function(a, b) return a < b end,
    2     string = function(a, b) return a < b end,
    2     other = function(a, b) return tostring(a) < tostring(b) end,
      }

      local function crossTypeSort(a, b)
****0     local type_a, type_b = type(a), type(b)
****0     if type_a == type_b then
****0         local func = crossTypeComparison[type_a] or crossTypeComparison.other
****0         return func(a, b)
          end
****0     type_a = crossTypeOrdering[type_a] or crossTypeOrdering.other
****0     type_b = crossTypeOrdering[type_b] or crossTypeOrdering.other
****0     return type_a < type_b
      end

      local function __genSortedIndex( t )
          -- Returns a sequence consisting of t's keys, sorted.
****0     local sortedIndex = {}

****0     for key,_ in pairs(t) do
****0         table.insert(sortedIndex, key)
          end

****0     table.sort(sortedIndex, crossTypeSort)
****0     return sortedIndex
      end
    2 M.private.__genSortedIndex = __genSortedIndex

      local function sortedNext(state, control)
          -- Equivalent of the next() function of table iteration, but returns the
          -- keys in sorted order (see __genSortedIndex and crossTypeSort).
          -- The state is a temporary variable during iteration and contains the
          -- sorted key table (state.sortedIdx). It also stores the last index (into
          -- the keys) used by the iteration, to find the next one quickly.
          local key

          --print("sortedNext: control = "..tostring(control) )
****0     if control == nil then
              -- start of iteration
****0         state.count = #state.sortedIdx
****0         state.lastIdx = 1
****0         key = state.sortedIdx[1]
****0         return key, state.t[key]
          end

          -- normally, we expect the control variable to match the last key used
****0     if control ~= state.sortedIdx[state.lastIdx] then
              -- strange, we have to find the next value by ourselves
              -- the key table is sorted in crossTypeSort() order! -> use bisection
****0         local lower, upper = 1, state.count
              repeat
****0             state.lastIdx = math.modf((lower + upper) / 2)
****0             key = state.sortedIdx[state.lastIdx]
****0             if key == control then
                      break -- key found (and thus prev index)
                  end
****0             if crossTypeSort(key, control) then
                      -- key < control, continue search "right" (towards upper bound)
****0                 lower = state.lastIdx + 1
                  else
                      -- key > control, continue search "left" (towards lower bound)
****0                 upper = state.lastIdx - 1
                  end
****0         until lower > upper
****0         if lower > upper then -- only true if the key wasn't found, ...
****0             state.lastIdx = state.count -- ... so ensure no match in code below
              end
          end

          -- proceed by retrieving the next value (or nil) from the sorted keys
****0     state.lastIdx = state.lastIdx + 1
****0     key = state.sortedIdx[state.lastIdx]
****0     if key then
****0         return key, state.t[key]
          end

          -- getting here means returning `nil`, which will end the iteration
      end

      local function sortedPairs(tbl)
          -- Equivalent of the pairs() function on tables. Allows to iterate in
          -- sorted order. As required by "generic for" loops, this will return the
          -- iterator (function), an "invariant state", and the initial control value.
          -- (see http://www.lua.org/pil/7.2.html)
****0     return sortedNext, {t = tbl, sortedIdx = __genSortedIndex(tbl)}, nil
      end
    2 M.private.sortedPairs = sortedPairs

      -- seed the random with a strongly varying seed
    2 math.randomseed(os.clock()*1E11)

      local function randomizeTable( t )
          -- randomize the item orders of the table t
****0     for i = #t, 2, -1 do
****0         local j = math.random(i)
****0         if i ~= j then
****0             t[i], t[j] = t[j], t[i]
              end
          end
      end
    2 M.private.randomizeTable = randomizeTable

      local function strsplit(delimiter, text)
      -- Split text into a list consisting of the strings in text, separated
      -- by strings matching delimiter (which may _NOT_ be a pattern).
      -- Example: strsplit(", ", "Anna, Bob, Charlie, Dolores")
****0     if delimiter == "" or delimiter == nil then -- this would result in endless loops
****0         error("delimiter is nil or empty string!")
          end
****0     if text == nil then
****0         return nil
          end

****0     local list, pos, first, last = {}, 1
          while true do
****0         first, last = text:find(delimiter, pos, true)
****0         if first then -- found?
****0             table.insert(list, text:sub(pos, first - 1))
****0             pos = last + 1
              else
****0             table.insert(list, text:sub(pos))
                  break
              end
          end
****0     return list
      end
    2 M.private.strsplit = strsplit

      local function hasNewLine( s )
          -- return true if s has a newline
****0     return (string.find(s, '\n', 1, true) ~= nil)
      end
    2 M.private.hasNewLine = hasNewLine

      local function prefixString( prefix, s )
          -- Prefix all the lines of s with prefix
****0     return prefix .. string.gsub(s, '\n', '\n' .. prefix)
      end
    2 M.private.prefixString = prefixString

      local function strMatch(s, pattern, start, final )
          -- return true if s matches completely the pattern from index start to index end
          -- return false in every other cases
          -- if start is nil, matches from the beginning of the string
          -- if final is nil, matches to the end of the string
****0     start = start or 1
****0     final = final or string.len(s)

****0     local foundStart, foundEnd = string.find(s, pattern, start, false)
****0     return foundStart == start and foundEnd == final
      end
    2 M.private.strMatch = strMatch

      local function patternFilter(patterns, expr)
          -- Run `expr` through the inclusion and exclusion rules defined in patterns
          -- and return true if expr shall be included, false for excluded.
          -- Inclusion pattern are defined as normal patterns, exclusions 
          -- patterns start with `!` and are followed by a normal pattern

          -- result: nil = UNKNOWN (not matched yet), true = ACCEPT, false = REJECT
          -- default: true if no explicit "include" is found, set to false otherwise
   32     local default, result = true, nil

   32     if patterns ~= nil then
****0         for _, pattern in ipairs(patterns) do
****0             local exclude = pattern:sub(1,1) == '!'
****0             if exclude then
****0                 pattern = pattern:sub(2)
                  else
                      -- at least one include pattern specified, a match is required
****0                 default = false
                  end
                  -- print('pattern: ',pattern)
                  -- print('exclude: ',exclude)
                  -- print('default: ',default)

****0             if string.find(expr, pattern) then
                      -- set result to false when excluding, true otherwise
****0                 result = not exclude
                  end
              end
          end

   32     if result ~= nil then
****0         return result
          end
   32     return default
      end
    2 M.private.patternFilter = patternFilter

      local function xmlEscape( s )
          -- Return s escaped for XML attributes
          -- escapes table:
          -- "   &quot;
          -- '   &apos;
          -- <   &lt;
          -- >   &gt;
          -- &   &amp;

****0     return string.gsub( s, '.', {
              ['&'] = "&amp;",
              ['"'] = "&quot;",
              ["'"] = "&apos;",
              ['<'] = "&lt;",
              ['>'] = "&gt;",
          } )
      end
    2 M.private.xmlEscape = xmlEscape

      local function xmlCDataEscape( s )
          -- Return s escaped for CData section, escapes: "]]>"
****0     return string.gsub( s, ']]>', ']]&gt;' )
      end
    2 M.private.xmlCDataEscape = xmlCDataEscape

      local function stripLuaunitTrace( stackTrace )
          --[[
          -- Example of  a traceback:
          <<stack traceback:
              example_with_luaunit.lua:130: in function 'test2_withFailure'
              ./luaunit.lua:1449: in function <./luaunit.lua:1449>
              [C]: in function 'xpcall'
              ./luaunit.lua:1449: in function 'protectedCall'
              ./luaunit.lua:1508: in function 'execOneFunction'
              ./luaunit.lua:1596: in function 'runSuiteByInstances'
              ./luaunit.lua:1660: in function 'runSuiteByNames'
              ./luaunit.lua:1736: in function 'runSuite'
              example_with_luaunit.lua:140: in main chunk
              [C]: in ?>>

              Other example:
          <<stack traceback:
              ./luaunit.lua:545: in function 'assertEquals'
              example_with_luaunit.lua:58: in function 'TestToto.test7'
              ./luaunit.lua:1517: in function <./luaunit.lua:1517>
              [C]: in function 'xpcall'
              ./luaunit.lua:1517: in function 'protectedCall'
              ./luaunit.lua:1578: in function 'execOneFunction'
              ./luaunit.lua:1677: in function 'runSuiteByInstances'
              ./luaunit.lua:1730: in function 'runSuiteByNames'
              ./luaunit.lua:1806: in function 'runSuite'
              example_with_luaunit.lua:140: in main chunk
              [C]: in ?>>

          <<stack traceback:
              luaunit2/example_with_luaunit.lua:124: in function 'test1_withFailure'
              luaunit2/luaunit.lua:1532: in function <luaunit2/luaunit.lua:1532>
              [C]: in function 'xpcall'
              luaunit2/luaunit.lua:1532: in function 'protectedCall'
              luaunit2/luaunit.lua:1591: in function 'execOneFunction'
              luaunit2/luaunit.lua:1679: in function 'runSuiteByInstances'
              luaunit2/luaunit.lua:1743: in function 'runSuiteByNames'
              luaunit2/luaunit.lua:1819: in function 'runSuite'
              luaunit2/example_with_luaunit.lua:140: in main chunk
              [C]: in ?>>


          -- first line is "stack traceback": KEEP
          -- next line may be luaunit line: REMOVE
          -- next lines are call in the program under testOk: REMOVE
          -- next lines are calls from luaunit to call the program under test: KEEP

          -- Strategy:
          -- keep first line
          -- remove lines that are part of luaunit
          -- kepp lines until we hit a luaunit line
          ]]

          local function isLuaunitInternalLine( s )
              -- return true if line of stack trace comes from inside luaunit
****0         return s:find('[/\\]luaunit%.lua:%d+: ') ~= nil
          end

          -- print( '<<'..stackTrace..'>>' )

****0     local t = strsplit( '\n', stackTrace )
          -- print( prettystr(t) )

****0     local idx = 2

          -- remove lines that are still part of luaunit
****0     while t[idx] and isLuaunitInternalLine( t[idx] ) do
              -- print('Removing : '..t[idx] )
****0         table.remove(t, idx)
          end

          -- keep lines until we hit luaunit again
****0     while t[idx] and (not isLuaunitInternalLine(t[idx])) do
              -- print('Keeping : '..t[idx] )
****0         idx = idx + 1
          end

          -- remove remaining luaunit lines
****0     while t[idx] do
              -- print('Removing : '..t[idx] )
****0         table.remove(t, idx)
          end

          -- print( prettystr(t) )
****0     return table.concat( t, '\n')

      end
    2 M.private.stripLuaunitTrace = stripLuaunitTrace


      local function prettystr_sub(v, indentLevel, printTableRefs, recursionTable )
****0     local type_v = type(v)
****0     if "string" == type_v  then
              -- use clever delimiters according to content:
              -- enclose with single quotes if string contains ", but no '
****0         if v:find('"', 1, true) and not v:find("'", 1, true) then
****0             return "'" .. v .. "'"
              end
              -- use double quotes otherwise, escape embedded "
****0         return '"' .. v:gsub('"', '\\"') .. '"'

****0     elseif "table" == type_v then
              --if v.__class__ then
              --    return string.gsub( tostring(v), 'table', v.__class__ )
              --end
****0         return M.private._table_tostring(v, indentLevel, printTableRefs, recursionTable)

****0     elseif "number" == type_v then
              -- eliminate differences in formatting between various Lua versions
****0         if v ~= v then
****0             return "#NaN" -- "not a number"
              end
****0         if v == math.huge then
****0             return "#Inf" -- "infinite"
              end
****0         if v == -math.huge then
****0             return "-#Inf"
              end
****0         if _VERSION == "Lua 5.3" then
****0             local i = math.tointeger(v)
****0             if i then
****0                 return tostring(i)
                  end
              end
          end

****0     return tostring(v)
      end

      local function prettystr( v )
          --[[ Pretty string conversion, to display the full content of a variable of any type.

          * string are enclosed with " by default, or with ' if string contains a "
          * tables are expanded to show their full content, with indentation in case of nested tables
          ]]--
****0     local recursionTable = {}
****0     local s = prettystr_sub(v, 1, M.PRINT_TABLE_REF_IN_ERROR_MSG, recursionTable)
****0     if recursionTable.recursionDetected and not M.PRINT_TABLE_REF_IN_ERROR_MSG then
              -- some table contain recursive references,
              -- so we must recompute the value by including all table references
              -- else the result looks like crap
****0         recursionTable = {}
****0         s = prettystr_sub(v, 1, true, recursionTable)
          end
****0     return s
      end
    2 M.prettystr = prettystr

    2 function M.adjust_err_msg_with_iter( err_msg, iter_msg )
          --[[ Adjust the error message err_msg: trim the FAILURE_PREFIX or SUCCESS_PREFIX information if needed, 
          add the iteration message if any and return the result.

          err_msg:  string, error message captured with pcall
          iter_msg: a string describing the current iteration ("iteration N") or nil
                    if there is no iteration in this test.

          Returns: (new_err_msg, test_status)
              new_err_msg: string, adjusted error message, or nil in case of success
              test_status: M.NodeStatus.FAIL, SUCCESS or ERROR according to the information
                           contained in the error message.
          ]]
****0     if iter_msg then
****0         iter_msg = iter_msg..', '
          else
****0         iter_msg = ''
          end

****0     local RE_FILE_LINE = '.*:%d+: '

          -- error message is not necessarily a string, 
          -- so convert the value to string with prettystr()
****0     if type( err_msg ) ~= 'string' then
****0         err_msg = prettystr( err_msg )
          end

****0     if (err_msg:find( M.SUCCESS_PREFIX ) == 1) or err_msg:match( '('..RE_FILE_LINE..')' .. M.SUCCESS_PREFIX .. ".*" ) then
              -- test finished early with success()
****0         return nil, M.NodeStatus.PASS
          end

****0     if (err_msg:find( M.FAILURE_PREFIX ) == 1) or (err_msg:match( '('..RE_FILE_LINE..')' .. M.FAILURE_PREFIX .. ".*" ) ~= nil) then
              -- substitute prefix by iteration message
****0         err_msg = err_msg:gsub(M.FAILURE_PREFIX, iter_msg, 1)
              -- print("failure detected")
****0         return err_msg, M.NodeStatus.FAIL
          else
              -- print("error detected")
              -- regular error, not a failure
****0         if iter_msg then
                  local match
                  -- "./test\\test_luaunit.lua:2241: some error msg
****0             match = err_msg:match( '(.*:%d+: ).*' ) 
****0             if match then
****0                 err_msg = err_msg:gsub( match, match .. iter_msg )
                  else
                      -- no file:line: infromation, just add the iteration info at the beginning of the line
****0                 err_msg = iter_msg .. err_msg
                  end
              end
****0         return err_msg, M.NodeStatus.ERROR
          end
      end

      local function tryMismatchFormatting( table_a, table_b, doDeepAnalysis )
          --[[
          Prepares a nice error message when comparing tables, performing a deeper 
          analysis.

          Arguments:
          * table_a, table_b: tables to be compared
          * doDeepAnalysis:
              M.DEFAULT_DEEP_ANALYSIS: (the default if not specified) perform deep analysis only for big lists and big dictionnaries
              M.FORCE_DEEP_ANALYSIS  : always perform deep analysis
              M.DISABLE_DEEP_ANALYSIS: never perform deep analysis

          Returns: {success, result}
          * success: false if deep analysis could not be performed 
                     in this case, just use standard assertion message
          * result: if success is true, a multi-line string with deep analysis of the two lists
          ]]

          -- check if table_a & table_b are suitable for deep analysis
****0     if type(table_a) ~= 'table' or type(table_b) ~= 'table' then
****0         return false
          end

****0     if doDeepAnalysis == M.DISABLE_DEEP_ANALYSIS then
****0         return false
          end

****0     local len_a, len_b, isPureList = #table_a, #table_b, true

****0     for k1, v1 in pairs(table_a) do
****0         if type(k1) ~= 'number' or k1 > len_a then
                  -- this table a mapping
****0             isPureList = false
                  break
              end
          end

****0     if isPureList then
****0         for k2, v2 in pairs(table_b) do
****0             if type(k2) ~= 'number' or k2 > len_b then
                      -- this table a mapping
****0                 isPureList = false
                      break
                  end
              end
          end

****0     if isPureList and math.min(len_a, len_b) < M.LIST_DIFF_ANALYSIS_THRESHOLD then
****0         if not (doDeepAnalysis == M.FORCE_DEEP_ANALYSIS) then
****0             return false
              end
          end

****0     if isPureList then
****0         return M.private.mismatchFormattingPureList( table_a, table_b )
          else
              -- only work on mapping for the moment
              -- return M.private.mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )
****0         return false
          end
      end
    2 M.private.tryMismatchFormatting = tryMismatchFormatting

      local function getTaTbDescr()
****0     if not M.ORDER_ACTUAL_EXPECTED then
****0         return 'expected', 'actual'
          end
****0     return 'actual', 'expected'
      end

      local function extendWithStrFmt( res, ... )
****0     table.insert( res, string.format( ... ) )
      end

      local function mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )
          --[[
          Prepares a nice error message when comparing tables which are not pure lists, performing a deeper 
          analysis.

          Returns: {success, result}
          * success: false if deep analysis could not be performed 
                     in this case, just use standard assertion message
          * result: if success is true, a multi-line string with deep analysis of the two lists
          ]]

          -- disable for the moment
          --[[
          local result = {}
          local descrTa, descrTb = getTaTbDescr()

          local keysCommon = {}
          local keysOnlyTa = {}
          local keysOnlyTb = {}
          local keysDiffTaTb = {}

          local k, v

          for k,v in pairs( table_a ) do
              if is_equal( v, table_b[k] ) then
                  table.insert( keysCommon, k )
              else 
                  if table_b[k] == nil then
                      table.insert( keysOnlyTa, k )
                  else
                      table.insert( keysDiffTaTb, k )
                  end
              end
          end

          for k,v in pairs( table_b ) do
              if not is_equal( v, table_a[k] ) and table_a[k] == nil then
                  table.insert( keysOnlyTb, k )
              end
          end

          local len_a = #keysCommon + #keysDiffTaTb + #keysOnlyTa
          local len_b = #keysCommon + #keysDiffTaTb + #keysOnlyTb
          local limited_display = (len_a < 5 or len_b < 5)

          if math.min(len_a, len_b) < M.TABLE_DIFF_ANALYSIS_THRESHOLD then
              return false
          end

          if not limited_display then
              if len_a == len_b then
                  extendWithStrFmt( result, 'Table A (%s) and B (%s) both have %d items', descrTa, descrTb, len_a )
              else
                  extendWithStrFmt( result, 'Table A (%s) has %d items and table B (%s) has %d items', descrTa, len_a, descrTb, len_b )
                  end

              if #keysCommon == 0 and #keysDiffTaTb == 0 then
                  table.insert( result, 'Table A and B have no keys in common, they are totally different')
              else
                  local s_other = 'other '
                  if #keysCommon then
                      extendWithStrFmt( result, 'Table A and B have %d identical items', #keysCommon )
                  else
                      table.insert( result, 'Table A and B have no identical items' )
                      s_other = ''
                  end

                  if #keysDiffTaTb ~= 0 then
                      result[#result] = string.format( '%s and %d items differing present in both tables', result[#result], #keysDiffTaTb)
                  else
                      result[#result] = string.format( '%s and no %sitems differing present in both tables', result[#result], s_other, #keysDiffTaTb)
                  end
              end

              extendWithStrFmt( result, 'Table A has %d keys not present in table B and table B has %d keys not present in table A', #keysOnlyTa, #keysOnlyTb ) 
          end

          local function keytostring(k)
              if "string" == type(k) and k:match("^[_%a][_%w]*$") then
                  return k
              end
              return prettystr(k)
          end

          if #keysDiffTaTb ~= 0 then
              table.insert( result, 'Items differing in A and B:')
              for k,v in sortedPairs( keysDiffTaTb ) do
                  extendWithStrFmt( result, '  - A[%s]: %s', keytostring(v), prettystr(table_a[v]) )
                  extendWithStrFmt( result, '  + B[%s]: %s', keytostring(v), prettystr(table_b[v]) )
              end
          end    

          if #keysOnlyTa ~= 0 then
              table.insert( result, 'Items only in table A:' )
              for k,v in sortedPairs( keysOnlyTa ) do
                  extendWithStrFmt( result, '  - A[%s]: %s', keytostring(v), prettystr(table_a[v]) )
              end
          end

          if #keysOnlyTb ~= 0 then
              table.insert( result, 'Items only in table B:' )
              for k,v in sortedPairs( keysOnlyTb ) do
                  extendWithStrFmt( result, '  + B[%s]: %s', keytostring(v), prettystr(table_b[v]) )
              end
          end

          if #keysCommon ~= 0 then
              table.insert( result, 'Items common to A and B:')
              for k,v in sortedPairs( keysCommon ) do
                  extendWithStrFmt( result, '  = A and B [%s]: %s', keytostring(v), prettystr(table_a[v]) )
              end
          end    

          return true, table.concat( result, '\n')
          ]]
      end
    2 M.private.mismatchFormattingMapping = mismatchFormattingMapping

      local function mismatchFormattingPureList( table_a, table_b )
          --[[
          Prepares a nice error message when comparing tables which are lists, performing a deeper 
          analysis.

          Returns: {success, result}
          * success: false if deep analysis could not be performed 
                     in this case, just use standard assertion message
          * result: if success is true, a multi-line string with deep analysis of the two lists
          ]]
****0     local result, descrTa, descrTb = {}, getTaTbDescr()

****0     local len_a, len_b, refa, refb = #table_a, #table_b, '', ''
****0     if M.PRINT_TABLE_REF_IN_ERROR_MSG then
****0         refa, refb = string.format( '<%s> ', tostring(table_a)), string.format('<%s> ', tostring(table_b) )
          end
****0     local longest, shortest = math.max(len_a, len_b), math.min(len_a, len_b)
****0     local deltalv  = longest - shortest

****0     local commonUntil = shortest
****0     for i = 1, shortest do
****0         if not is_equal(table_a[i], table_b[i]) then
****0             commonUntil = i - 1
                  break
              end
          end

****0     local commonBackTo = shortest - 1
****0     for i = 0, shortest - 1 do
****0         if not is_equal(table_a[len_a-i], table_b[len_b-i]) then
****0             commonBackTo = i - 1
                  break
              end
          end


****0     table.insert( result, 'List difference analysis:' )    
****0     if len_a == len_b then
              -- TODO: handle expected/actual naming
****0         extendWithStrFmt( result, '* lists %sA (%s) and %sB (%s) have the same size', refa, descrTa, refb, descrTb )
          else 
****0         extendWithStrFmt( result, '* list sizes differ: list %sA (%s) has %d items, list %sB (%s) has %d items', refa, descrTa, len_a, refb, descrTb, len_b )
          end

****0     extendWithStrFmt( result, '* lists A and B start differing at index %d', commonUntil+1 ) 
****0     if commonBackTo >= 0 then
****0         if deltalv > 0 then
****0             extendWithStrFmt( result, '* lists A and B are equal again from index %d for A, %d for B', len_a-commonBackTo, len_b-commonBackTo )
              else
****0             extendWithStrFmt( result, '* lists A and B are equal again from index %d', len_a-commonBackTo )
              end
          end

          local function insertABValue(ai, bi)
****0         bi = bi or ai
****0         if is_equal( table_a[ai], table_b[bi]) then
****0             return extendWithStrFmt( result, '  = A[%d], B[%d]: %s', ai, bi, prettystr(table_a[ai]) )
              else
****0             extendWithStrFmt( result, '  - A[%d]: %s', ai, prettystr(table_a[ai]))
****0             extendWithStrFmt( result, '  + B[%d]: %s', bi, prettystr(table_b[bi]))
              end
          end

          -- common parts to list A & B, at the beginning
****0     if commonUntil > 0 then
****0         table.insert( result, '* Common parts:' )
****0         for i = 1, commonUntil do
****0             insertABValue( i )
              end
          end

          -- diffing parts to list A & B
****0     if commonUntil < shortest - commonBackTo - 1 then
****0         table.insert( result, '* Differing parts:' )
****0         for i = commonUntil + 1, shortest - commonBackTo - 1 do
****0             insertABValue( i )
              end
          end

          -- display indexes of one list, with no match on other list
****0     if shortest - commonBackTo <= longest - commonBackTo - 1 then
****0         table.insert( result, '* Present only in one list:' )
****0         for i = shortest - commonBackTo, longest - commonBackTo - 1 do
****0             if len_a > len_b then
****0                 extendWithStrFmt( result, '  - A[%d]: %s', i, prettystr(table_a[i]) )
                      -- table.insert( result, '+ (no matching B index)')
                  else
                      -- table.insert( result, '- no matching A index')
****0                 extendWithStrFmt( result, '  + B[%d]: %s', i, prettystr(table_b[i]) )
                  end
              end
          end

          -- common parts to list A & B, at the end
****0     if commonBackTo >= 0 then
****0         table.insert( result, '* Common parts at the end of the lists' )
****0         for i = longest - commonBackTo, longest do
****0             if len_a > len_b then
****0                 insertABValue( i, i-deltalv )
                  else
****0                 insertABValue( i-deltalv, i )
                  end
              end
          end

****0     return true, table.concat( result, '\n')
      end
    2 M.private.mismatchFormattingPureList = mismatchFormattingPureList

      local function prettystrPairs(value1, value2, suffix_a, suffix_b)
          --[[
          This function helps with the recurring task of constructing the "expected
          vs. actual" error messages. It takes two arbitrary values and formats
          corresponding strings with prettystr().

          To keep the (possibly complex) output more readable in case the resulting
          strings contain line breaks, they get automatically prefixed with additional
          newlines. Both suffixes are optional (default to empty strings), and get
          appended to the "value1" string. "suffix_a" is used if line breaks were
          encountered, "suffix_b" otherwise.

          Returns the two formatted strings (including padding/newlines).
          ]]
****0     local str1, str2 = prettystr(value1), prettystr(value2)
****0     if hasNewLine(str1) or hasNewLine(str2) then
              -- line break(s) detected, add padding
****0         return "\n" .. str1 .. (suffix_a or ""), "\n" .. str2
          end
****0     return str1 .. (suffix_b or ""), str2
      end
    2 M.private.prettystrPairs = prettystrPairs

      local function _table_raw_tostring( t )
          -- return the default tostring() for tables, with the table ID, even if the table has a metatable
          -- with the __tostring converter
****0     local mt = getmetatable( t )
****0     if mt then setmetatable( t, nil ) end
****0     local ref = tostring(t)
****0     if mt then setmetatable( t, mt ) end
****0     return ref
      end
    2 M.private._table_raw_tostring = _table_raw_tostring

    2 local TABLE_TOSTRING_SEP = ", "
    2 local TABLE_TOSTRING_SEP_LEN = string.len(TABLE_TOSTRING_SEP)

      local function _table_tostring( tbl, indentLevel, printTableRefs, recursionTable )
****0     printTableRefs = printTableRefs or M.PRINT_TABLE_REF_IN_ERROR_MSG
****0     recursionTable = recursionTable or {}
****0     recursionTable[tbl] = true

****0     local result, dispOnMultLines = {}, false

          -- like prettystr but do not enclose with "" if the string is just alphanumerical
          -- this is better for displaying table keys who are often simple strings
          local function keytostring(k)
****0         if "string" == type(k) and k:match("^[_%a][_%w]*$") then
****0             return k
              end
****0         return prettystr_sub(k, indentLevel+1, printTableRefs, recursionTable)
          end

****0     local mt = getmetatable( tbl )

****0     if mt and mt.__tostring then
              -- if table has a __tostring() function in its metatable, use it to display the table
              -- else, compute a regular table
****0         result = tostring(tbl)
****0         if type(result) ~= 'string' then
****0             return string.format( '<invalid tostring() result: "%s" >', prettystr(result) )
              end
****0         result = strsplit( '\n', result )
****0         return M.private._table_tostring_format_multiline_string( result, indentLevel )

          else
              -- no metatable, compute the table representation

****0         local entry, count, seq_index = nil, 0, 1
****0         for k, v in sortedPairs( tbl ) do

                  -- key part
****0             if k == seq_index then
                      -- for the sequential part of tables, we'll skip the "<key>=" output
****0                 entry = ''
****0                 seq_index = seq_index + 1
****0             elseif recursionTable[k] then
                      -- recursion in the key detected
****0                 recursionTable.recursionDetected = true
****0                 entry = "<".._table_raw_tostring(k)..">="
                  else
****0                 entry = keytostring(k) .. "="
                  end

                  -- value part 
****0             if recursionTable[v] then
                      -- recursion in the value detected!
****0                 recursionTable.recursionDetected = true
****0                 entry = entry .. "<".._table_raw_tostring(v)..">"
                  else
****0                 entry = entry ..
****0                     prettystr_sub( v, indentLevel+1, printTableRefs, recursionTable )
                  end
****0             count = count + 1
****0             result[count] = entry
              end
****0         return M.private._table_tostring_format_result( tbl, result, indentLevel, printTableRefs )
          end

      end
    2 M.private._table_tostring = _table_tostring -- prettystr_sub() needs it

      local function _table_tostring_format_multiline_string( tbl_str, indentLevel )
****0     local indentString = '\n'..string.rep("    ", indentLevel - 1)
****0     return table.concat( tbl_str, indentString )

      end
    2 M.private._table_tostring_format_multiline_string = _table_tostring_format_multiline_string


      local function _table_tostring_format_result( tbl, result, indentLevel, printTableRefs )
          -- final function called in _table_to_string() to format the resulting list of 
          -- string describing the table.

****0     local dispOnMultLines = false

          -- set dispOnMultLines to true if the maximum LINE_LENGTH would be exceeded with the values
****0     local totalLength = 0
****0     for k, v in ipairs( result ) do
****0         totalLength = totalLength + string.len( v )
****0         if totalLength >= M.LINE_LENGTH then
****0             dispOnMultLines = true
                  break
              end
          end

          -- set dispOnMultLines to true if the max LINE_LENGTH would be exceeded
          -- with the values and the separators.
****0     if not dispOnMultLines then
              -- adjust with length of separator(s):
              -- two items need 1 sep, three items two seps, ... plus len of '{}'
****0         if #result > 0 then
****0             totalLength = totalLength + TABLE_TOSTRING_SEP_LEN * (#result - 1)
              end
****0         dispOnMultLines = (totalLength + 2 >= M.LINE_LENGTH)
          end

          -- now reformat the result table (currently holding element strings)
****0     if dispOnMultLines then
****0         local indentString = string.rep("    ", indentLevel - 1)
****0         result = {  
                          "{\n    ", 
                          indentString,
****0                     table.concat(result, ",\n    " .. indentString), 
                          "\n",
                          indentString, 
                          "}"
                      }
          else
****0         result = {"{", table.concat(result, TABLE_TOSTRING_SEP), "}"}
          end
****0     if printTableRefs then
****0         table.insert(result, 1, "<".._table_raw_tostring(tbl).."> ") -- prepend table ref
          end
****0     return table.concat(result)
      end
    2 M.private._table_tostring_format_result = _table_tostring_format_result -- prettystr_sub() needs it

      local function _table_contains(t, element)
****0     if type(t) == "table" then
****0         local type_e = type(element)
****0         for _, value in pairs(t) do
****0             if type(value) == type_e then
****0                 if value == element then
****0                     return true
                      end
****0                 if type_e == 'table' then
                          -- if we wanted recursive items content comparison, we could use
                          -- _is_table_items_equals(v, expected) but one level of just comparing
                          -- items is sufficient
****0                     if M.private._is_table_equals( value, element ) then
****0                         return true
                          end
                      end
                  end
              end
          end
****0     return false
      end

      local function _is_table_items_equals(actual, expected )
****0     local type_a, type_e = type(actual), type(expected)

****0     if (type_a == 'table') and (type_e == 'table') then
****0         for k, v in pairs(actual) do
****0             if not _table_contains(expected, v) then
****0                 return false
                  end
              end
****0         for k, v in pairs(expected) do
****0             if not _table_contains(actual, v) then
****0                 return false
                  end
              end
****0         return true

****0     elseif type_a ~= type_e then
****0         return false

****0     elseif actual ~= expected then
****0         return false
          end

****0     return true
      end

      --[[
      This is a specialized metatable to help with the bookkeeping of recursions
      in _is_table_equals(). It provides an __index table that implements utility
      functions for easier management of the table. The "cached" method queries
      the state of a specific (actual,expected) pair; and the "store" method sets
      this state to the given value. The state of pairs not "seen" / visited is
      assumed to be `nil`.
      ]]
    2 local _recursion_cache_MT = {
    2     __index = {
              -- Return the cached value for an (actual,expected) pair (or `nil`)
              cached = function(t, actual, expected)
****0             local subtable = t[actual] or {}
****0             return subtable[expected]
              end,

              -- Store cached value for a specific (actual,expected) pair.
              -- Returns the value, so it's easy to use for a "tailcall" (return ...).
              store = function(t, actual, expected, value, asymmetric)
****0             local subtable = t[actual]
****0             if not subtable then
****0                 subtable = {}
****0                 t[actual] = subtable
                  end
****0             subtable[expected] = value

                  -- Unless explicitly marked "asymmetric": Consider the recursion
                  -- on (expected,actual) to be equivalent to (actual,expected) by
                  -- default, and thus cache the value for both.
****0             if not asymmetric then
****0                 t:store(expected, actual, value, true)
                  end

****0             return value
              end
    2     }
      }

      local function _is_table_equals(actual, expected, recursions)
****0     local type_a, type_e = type(actual), type(expected)
****0     recursions = recursions or setmetatable({}, _recursion_cache_MT)

****0     if type_a ~= type_e then
****0         return false -- different types won't match
          end

****0     if (type_a == 'table') --[[ and (type_e == 'table') ]] then
****0         if actual == expected then
                  -- Both reference the same table, so they are actually identical
****0             return recursions:store(actual, expected, true)
              end

              -- If we've tested this (actual,expected) pair before: return cached value
****0         local previous = recursions:cached(actual, expected)
****0         if previous ~= nil then
****0             return previous
              end

              -- Mark this (actual,expected) pair, so we won't recurse it again. For
              -- now, assume a "false" result, which we might adjust later if needed.
****0         recursions:store(actual, expected, false)

              -- Tables must have identical element count, or they can't match.
****0         if (#actual ~= #expected) then
****0             return false
              end

****0         local actualKeysMatched, actualTableKeys = {}, {}

****0         for k, v in pairs(actual) do
****0             if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
                      -- If the keys are tables, things get a bit tricky here as we
                      -- can have _is_table_equals(t[k1], t[k2]) despite k1 ~= k2. So
                      -- we first collect table keys from "actual", and then later try
                      -- to match each table key from "expected" to actualTableKeys.
****0                 table.insert(actualTableKeys, k)
                  else
****0                 if not _is_table_equals(v, expected[k], recursions) then
****0                     return false -- Mismatch on value, tables can't be equal
                      end
****0                 actualKeysMatched[k] = true -- Keep track of matched keys
                  end
              end

****0         for k, v in pairs(expected) do
****0             if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
****0                 local found = false
                      -- Note: DON'T use ipairs() here, table may be non-sequential!
****0                 for i, candidate in pairs(actualTableKeys) do
****0                     if _is_table_equals(candidate, k, recursions) then
****0                         if _is_table_equals(actual[candidate], v, recursions) then
****0                             found = true
                                  -- Remove the candidate we matched against from the list
                                  -- of table keys, so each key in actual can only match
                                  -- one key in expected.
****0                             actualTableKeys[i] = nil
                                  break
                              end
                              -- keys match but values don't, keep searching
                          end
                      end
****0                 if not found then
****0                     return false -- no matching (key,value) pair
                      end
                  else
****0                 if not actualKeysMatched[k] then
                          -- Found a key that we did not see in "actual" -> mismatch
****0                     return false
                      end
                      -- Otherwise actual[k] was already matched against v = expected[k].
                  end
              end

****0         if next(actualTableKeys) then
                  -- If there is any key left in actualTableKeys, then that is
                  -- a table-type key in actual with no matching counterpart
                  -- (in expected), and so the tables aren't equal.
****0             return false
              end

              -- The tables are actually considered equal, update cache and return result
****0         return recursions:store(actual, expected, true)

****0     elseif actual ~= expected then
****0         return false
          end

****0     return true
      end
    2 M.private._is_table_equals = _is_table_equals
    2 is_equal = _is_table_equals

      local function failure(main_msg, extra_msg_or_nil, level)
          -- raise an error indicating a test failure
          -- for error() compatibility we adjust "level" here (by +1), to report the
          -- calling context
          local msg
****0     if type(extra_msg_or_nil) == 'string' and extra_msg_or_nil:len() > 0 then
****0         msg = extra_msg_or_nil .. '\n' .. main_msg
          else
****0         msg = main_msg
          end
****0     error(M.FAILURE_PREFIX .. msg, (level or 1) + 1)
      end

      local function fail_fmt(level, extra_msg_or_nil, ...)
           -- failure with printf-style formatted message and given error level
****0     failure(string.format(...), extra_msg_or_nil, (level or 1) + 1)
      end
    2 M.private.fail_fmt = fail_fmt

      local function error_fmt(level, ...)
           -- printf-style error()
****0     error(string.format(...), (level or 1) + 1)
      end

      ----------------------------------------------------------------
      --
      --                     assertions
      --
      ----------------------------------------------------------------

      local function errorMsgEquality(actual, expected, doDeepAnalysis)

****0     if not M.ORDER_ACTUAL_EXPECTED then
****0         expected, actual = actual, expected
          end
****0     if type(expected) == 'string' or type(expected) == 'table' then
****0         local strExpected, strActual = prettystrPairs(expected, actual)
****0         local result = string.format("expected: %s\nactual: %s", strExpected, strActual)

              -- extend with mismatch analysis if possible:
              local success, mismatchResult
****0         success, mismatchResult = tryMismatchFormatting( actual, expected, doDeepAnalysis )
****0         if success then 
****0             result = table.concat( { result, mismatchResult }, '\n' )
              end
****0         return result
          end
****0     return string.format("expected: %s, actual: %s",
****0                          prettystr(expected), prettystr(actual))
      end

    2 function M.assertError(f, ...)
          -- assert that calling f with the arguments will raise an error
          -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
****0     if pcall( f, ... ) then
****0         failure( "Expected an error when calling function but no error generated", nil, 2 )
          end
      end

    2 function M.fail( msg )
          -- stops a test due to a failure
****0     failure( msg, nil, 2 )
      end

    2 function M.failIf( cond, msg )
          -- Fails a test with "msg" if condition is true
****0     if cond then
****0         failure( msg, nil, 2 )
          end
      end

    2 function M.success()
          -- stops a test with a success
****0     error(M.SUCCESS_PREFIX, 2)
      end

    2 function M.successIf( cond )
          -- stops a test with a success if condition is met
****0     if cond then
****0         error(M.SUCCESS_PREFIX, 2)
          end
      end


      ------------------------------------------------------------------
      --                  Equality assertions
      ------------------------------------------------------------------

    2 function M.assertEquals(actual, expected, extra_msg_or_nil, doDeepAnalysis)
  150     if type(actual) == 'table' and type(expected) == 'table' then
****0         if not _is_table_equals(actual, expected) then
****0             failure( errorMsgEquality(actual, expected, doDeepAnalysis), extra_msg_or_nil, 2 )
              end
  150     elseif type(actual) ~= type(expected) then
****0         failure( errorMsgEquality(actual, expected), extra_msg_or_nil, 2 )
  150     elseif actual ~= expected then
****0         failure( errorMsgEquality(actual, expected), extra_msg_or_nil, 2 )
          end
      end

    2 function M.almostEquals( actual, expected, margin )
****0     if type(actual) ~= 'number' or type(expected) ~= 'number' or type(margin) ~= 'number' then
****0         error_fmt(3, 'almostEquals: must supply only number arguments.\nArguments supplied: %s, %s, %s',
****0             prettystr(actual), prettystr(expected), prettystr(margin))
          end
****0     if margin < 0 then
****0         error('almostEquals: margin must not be negative, current value is ' .. margin, 3)
          end
****0     return math.abs(expected - actual) <= margin
      end

    2 function M.assertAlmostEquals( actual, expected, margin, extra_msg_or_nil )
          -- check that two floats are close by margin
****0     margin = margin or M.EPS
****0     if not M.almostEquals(actual, expected, margin) then
****0         if not M.ORDER_ACTUAL_EXPECTED then
****0             expected, actual = actual, expected
              end
****0         local delta = math.abs(actual - expected) 
****0         fail_fmt(2, extra_msg_or_nil, 'Values are not almost equal\n' ..
                          'Actual: %s, expected: %s, delta %s above margin of %s',
****0                     actual, expected, delta, margin)
          end
      end

    2 function M.assertNotEquals(actual, expected, extra_msg_or_nil)
****0     if type(actual) ~= type(expected) then
****0         return
          end

****0     if type(actual) == 'table' and type(expected) == 'table' then
****0         if not _is_table_equals(actual, expected) then
****0             return
              end
****0     elseif actual ~= expected then
****0         return
          end
****0     fail_fmt(2, extra_msg_or_nil, 'Received the not expected value: %s', prettystr(actual))
      end

    2 function M.assertNotAlmostEquals( actual, expected, margin, extra_msg_or_nil )
          -- check that two floats are not close by margin
****0     margin = margin or M.EPS
****0     if M.almostEquals(actual, expected, margin) then
****0         if not M.ORDER_ACTUAL_EXPECTED then
****0             expected, actual = actual, expected
              end
****0         local delta = math.abs(actual - expected)
****0         fail_fmt(2, extra_msg_or_nil, 'Values are almost equal\nActual: %s, expected: %s' ..
                          ', delta %s below margin of %s',
****0                     actual, expected, delta, margin)
          end
      end

    2 function M.assertItemsEquals(actual, expected, extra_msg_or_nil)
          -- checks that the items of table expected
          -- are contained in table actual. Warning, this function
          -- is at least O(n^2)
****0     if not _is_table_items_equals(actual, expected ) then
****0         expected, actual = prettystrPairs(expected, actual)
****0         fail_fmt(2, extra_msg_or_nil, 'Content of the tables are not identical:\nExpected: %s\nActual: %s',
****0                  expected, actual)
          end
      end

      ------------------------------------------------------------------
      --                  String assertion
      ------------------------------------------------------------------

    2 function M.assertStrContains( str, sub, isPattern, extra_msg_or_nil )
          -- this relies on lua string.find function
          -- a string always contains the empty string
****0     if not string.find(str, sub, 1, not isPattern) then
****0         sub, str = prettystrPairs(sub, str, '\n')
****0         fail_fmt(2, extra_msg_or_nil, 'Could not find %s %s in string %s',
****0                  isPattern and 'pattern' or 'substring', sub, str)
          end
      end

    2 function M.assertStrIContains( str, sub, extra_msg_or_nil )
          -- this relies on lua string.find function
          -- a string always contains the empty string
****0     if not string.find(str:lower(), sub:lower(), 1, true) then
****0         sub, str = prettystrPairs(sub, str, '\n')
****0         fail_fmt(2, extra_msg_or_nil, 'Could not find (case insensitively) substring %s in string %s',
****0                  sub, str)
          end
      end

    2 function M.assertNotStrContains( str, sub, isPattern, extra_msg_or_nil )
          -- this relies on lua string.find function
          -- a string always contains the empty string
****0     if string.find(str, sub, 1, not isPattern) then
****0         sub, str = prettystrPairs(sub, str, '\n')
****0         fail_fmt(2, extra_msg_or_nil, 'Found the not expected %s %s in string %s',
****0                  isPattern and 'pattern' or 'substring', sub, str)
          end
      end

    2 function M.assertNotStrIContains( str, sub, extra_msg_or_nil )
          -- this relies on lua string.find function
          -- a string always contains the empty string
****0     if string.find(str:lower(), sub:lower(), 1, true) then
****0         sub, str = prettystrPairs(sub, str, '\n')
****0         fail_fmt(2, extra_msg_or_nil, 'Found (case insensitively) the not expected substring %s in string %s',
****0                  sub, str)
          end
      end

    2 function M.assertStrMatches( str, pattern, start, final, extra_msg_or_nil )
          -- Verify a full match for the string
****0     if not strMatch( str, pattern, start, final ) then
****0         pattern, str = prettystrPairs(pattern, str, '\n')
****0         fail_fmt(2, extra_msg_or_nil, 'Could not match pattern %s with string %s',
****0                  pattern, str)
          end
      end

      local function _assertErrorMsgEquals( stripFileAndLine, expectedMsg, func, ... )
****0     local no_error, error_msg = pcall( func, ... )
****0     if no_error then
****0         failure( 'No error generated when calling function but expected error: '..M.prettystr(expectedMsg), nil, 3 )
          end
****0     if type(expectedMsg) == "string" and type(error_msg) ~= "string" then
              -- table are converted to string automatically
****0         error_msg = tostring(error_msg)
          end
****0     local differ = false
****0     if stripFileAndLine then
****0         if error_msg:gsub("^.+:%d+: ", "") ~= expectedMsg then
****0             differ = true
              end
          else
****0         if error_msg ~= expectedMsg then
****0             local tr = type(error_msg)
****0             local te = type(expectedMsg)
****0             if te == 'table' then
****0                 if tr ~= 'table' then
****0                     differ = true
                      else
****0                      local ok = pcall(M.assertItemsEquals, error_msg, expectedMsg)
****0                      if not ok then
****0                          differ = true
                           end
                      end
                  else
****0                differ = true
                  end
              end
          end

****0     if differ then
****0         error_msg, expectedMsg = prettystrPairs(error_msg, expectedMsg)
****0         fail_fmt(3, nil, 'Error message expected: %s\nError message received: %s\n',
****0                  expectedMsg, error_msg)
          end
      end

    2 function M.assertErrorMsgEquals( expectedMsg, func, ... )
          -- assert that calling f with the arguments will raise an error
          -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
****0     _assertErrorMsgEquals(false, expectedMsg, func, ...)
      end

    2 function M.assertErrorMsgContentEquals(expectedMsg, func, ...)
****0      _assertErrorMsgEquals(true, expectedMsg, func, ...)
      end

    2 function M.assertErrorMsgContains( partialMsg, func, ... )
          -- assert that calling f with the arguments will raise an error
          -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
****0     local no_error, error_msg = pcall( func, ... )
****0     if no_error then
****0         failure( 'No error generated when calling function but expected error containing: '..prettystr(partialMsg), nil, 2 )
          end
****0     if type(error_msg) ~= "string" then
****0         error_msg = tostring(error_msg)
          end
****0     if not string.find( error_msg, partialMsg, nil, true ) then
****0         error_msg, partialMsg = prettystrPairs(error_msg, partialMsg)
****0         fail_fmt(2, nil, 'Error message does not contain: %s\nError message received: %s\n',
****0                  partialMsg, error_msg)
          end
      end

    2 function M.assertErrorMsgMatches( expectedMsg, func, ... )
          -- assert that calling f with the arguments will raise an error
          -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
****0     local no_error, error_msg = pcall( func, ... )
****0     if no_error then
****0         failure( 'No error generated when calling function but expected error matching: "'..expectedMsg..'"', nil, 2 )
          end
****0     if type(error_msg) ~= "string" then
****0         error_msg = tostring(error_msg)
          end
****0     if not strMatch( error_msg, expectedMsg ) then
****0         expectedMsg, error_msg = prettystrPairs(expectedMsg, error_msg)
****0         fail_fmt(2, nil, 'Error message does not match pattern: %s\nError message received: %s\n',
****0                  expectedMsg, error_msg)
          end
      end

      ------------------------------------------------------------------
      --              Type assertions
      ------------------------------------------------------------------

    2 function M.assertEvalToTrue(value, extra_msg_or_nil)
****0     if not value then
****0         failure("expected: a value evaluating to true, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertEvalToFalse(value, extra_msg_or_nil)
****0     if value then
****0         failure("expected: false or nil, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsTrue(value, extra_msg_or_nil)
****0     if value ~= true then
****0         failure("expected: true, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsTrue(value, extra_msg_or_nil)
****0     if value == true then
****0         failure("expected: not true, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsFalse(value, extra_msg_or_nil)
****0     if value ~= false then
****0         failure("expected: false, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsFalse(value, extra_msg_or_nil)
****0     if value == false then
****0         failure("expected: not false, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsNil(value, extra_msg_or_nil)
****0     if value ~= nil then
****0         failure("expected: nil, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsNil(value, extra_msg_or_nil)
****0     if value == nil then
****0         failure("expected: not nil, actual: nil", extra_msg_or_nil, 2)
          end
      end

      --[[
      Add type assertion functions to the module table M. Each of these functions
      takes a single parameter "value", and checks that its Lua type matches the
      expected string (derived from the function name):

      M.assertIsXxx(value) -> ensure that type(value) conforms to "xxx"
      ]]
   20 for _, funcName in ipairs(
    2     {'assertIsNumber', 'assertIsString', 'assertIsTable', 'assertIsBoolean',
    2      'assertIsFunction', 'assertIsUserdata', 'assertIsThread'}
    2 ) do
   14     local typeExpected = funcName:match("^assertIs([A-Z]%a*)$")
          -- Lua type() always returns lowercase, also make sure the match() succeeded
   14     typeExpected = typeExpected and typeExpected:lower()
   14                    or error("bad function name '"..funcName.."' for type assertion")

          M[funcName] = function(value, extra_msg_or_nil)
****0         if type(value) ~= typeExpected then
****0             if type(value) == 'nil' then
****0                 fail_fmt(2, extra_msg_or_nil, 'expected: a %s value, actual: nil',
****0                          typeExpected, type(value), prettystrPairs(value))
                  else
****0                 fail_fmt(2, extra_msg_or_nil, 'expected: a %s value, actual: type %s, value %s',
****0                          typeExpected, type(value), prettystrPairs(value))
                  end
              end
          end
      end

      --[[
      Add shortcuts for verifying type of a variable, without failure (luaunit v2 compatibility)
      M.isXxx(value) -> returns true if type(value) conforms to "xxx"
      ]]
   22 for _, typeExpected in ipairs(
    2     {'Number', 'String', 'Table', 'Boolean',
    2      'Function', 'Userdata', 'Thread', 'Nil' }
    2 ) do
   16     local typeExpectedLower = typeExpected:lower()
          local isType = function(value)
****0         return (type(value) == typeExpectedLower)
          end
   16     M['is'..typeExpected] = isType
   16     M['is_'..typeExpectedLower] = isType
      end

      --[[
      Add non-type assertion functions to the module table M. Each of these functions
      takes a single parameter "value", and checks that its Lua type differs from the
      expected string (derived from the function name):

      M.assertNotIsXxx(value) -> ensure that type(value) is not "xxx"
      ]]
   20 for _, funcName in ipairs(
    2     {'assertNotIsNumber', 'assertNotIsString', 'assertNotIsTable', 'assertNotIsBoolean',
    2      'assertNotIsFunction', 'assertNotIsUserdata', 'assertNotIsThread'}
    2 ) do
   14     local typeUnexpected = funcName:match("^assertNotIs([A-Z]%a*)$")
          -- Lua type() always returns lowercase, also make sure the match() succeeded
   14     typeUnexpected = typeUnexpected and typeUnexpected:lower()
   14                    or error("bad function name '"..funcName.."' for type assertion")

          M[funcName] = function(value, extra_msg_or_nil)
****0         if type(value) == typeUnexpected then
****0             fail_fmt(2, extra_msg_or_nil, 'expected: not a %s type, actual: value %s',
****0                      typeUnexpected, prettystrPairs(value))
              end
          end
      end

    2 function M.assertIs(actual, expected, extra_msg_or_nil)
****0     if actual ~= expected then
****0         if not M.ORDER_ACTUAL_EXPECTED then
****0             actual, expected = expected, actual
              end
****0         expected, actual = prettystrPairs(expected, actual, '\n', '')
****0         fail_fmt(2, extra_msg_or_nil, 'expected and actual object should not be different\nExpected: %s\nReceived: %s',
****0                  expected, actual)
          end
      end

    2 function M.assertNotIs(actual, expected, extra_msg_or_nil)
****0     if actual == expected then
****0         if not M.ORDER_ACTUAL_EXPECTED then
****0             expected = actual
              end
****0         fail_fmt(2, extra_msg_or_nil, 'expected and actual object should be different: %s',
****0                  prettystrPairs(expected))
          end
      end


      ------------------------------------------------------------------
      --              Scientific assertions
      ------------------------------------------------------------------


    2 function M.assertIsNaN(value, extra_msg_or_nil)
****0     if type(value) ~= "number" or value == value then
****0         failure("expected: NaN, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsNaN(value, extra_msg_or_nil)
****0     if type(value) == "number" and value ~= value then
****0         failure("expected: not NaN, actual: NaN", extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsInf(value, extra_msg_or_nil)
****0     if type(value) ~= "number" or math.abs(value) ~= math.huge then
****0         failure("expected: #Inf, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsPlusInf(value, extra_msg_or_nil)
****0     if type(value) ~= "number" or value ~= math.huge then
****0         failure("expected: #Inf, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsMinusInf(value, extra_msg_or_nil)
****0     if type(value) ~= "number" or value ~= -math.huge then
****0         failure("expected: -#Inf, actual: " ..prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsPlusInf(value, extra_msg_or_nil)
****0     if type(value) == "number" and value == math.huge then
****0         failure("expected: not #Inf, actual: #Inf", extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsMinusInf(value, extra_msg_or_nil)
****0     if type(value) == "number" and value == -math.huge then
****0         failure("expected: not -#Inf, actual: -#Inf", extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsInf(value, extra_msg_or_nil)
****0     if type(value) == "number" and math.abs(value) == math.huge then
****0         failure("expected: not infinity, actual: " .. prettystr(value), extra_msg_or_nil, 2)
          end
      end

    2 function M.assertIsPlusZero(value, extra_msg_or_nil)
****0     if type(value) ~= 'number' or value ~= 0 then
****0         failure("expected: +0.0, actual: " ..prettystr(value), extra_msg_or_nil, 2)
****0     else if (1/value == -math.huge) then
                  -- more precise error diagnosis
****0             failure("expected: +0.0, actual: -0.0", extra_msg_or_nil, 2)
****0         else if (1/value ~= math.huge) then
                      -- strange, case should have already been covered
****0                 failure("expected: +0.0, actual: " ..prettystr(value), extra_msg_or_nil, 2)
                  end
              end
          end
      end

    2 function M.assertIsMinusZero(value, extra_msg_or_nil)
****0     if type(value) ~= 'number' or value ~= 0 then
****0         failure("expected: -0.0, actual: " ..prettystr(value), extra_msg_or_nil, 2)
****0     else if (1/value == math.huge) then
                  -- more precise error diagnosis
****0             failure("expected: -0.0, actual: +0.0", extra_msg_or_nil, 2)
****0         else if (1/value ~= -math.huge) then
                      -- strange, case should have already been covered
****0                 failure("expected: -0.0, actual: " ..prettystr(value), extra_msg_or_nil, 2)
                  end
              end
          end
      end

    2 function M.assertNotIsPlusZero(value, extra_msg_or_nil)
****0     if type(value) == 'number' and (1/value == math.huge) then
****0         failure("expected: not +0.0, actual: +0.0", extra_msg_or_nil, 2)
          end
      end

    2 function M.assertNotIsMinusZero(value, extra_msg_or_nil)
****0     if type(value) == 'number' and (1/value == -math.huge) then
****0         failure("expected: not -0.0, actual: -0.0", extra_msg_or_nil, 2)
          end
      end

      ----------------------------------------------------------------
      --                     Compatibility layer
      ----------------------------------------------------------------

      -- for compatibility with LuaUnit v2.x
    2 function M.wrapFunctions()
          -- In LuaUnit version <= 2.1 , this function was necessary to include
          -- a test function inside the global test suite. Nowadays, the functions
          -- are simply run directly as part of the test discovery process.
          -- so just do nothing !
****0     io.stderr:write[[Use of WrapFunctions() is no longer needed.
      Just prefix your test function names with "test" or "Test" and they
      will be picked up and run by LuaUnit.
****0 ]]
      end

    2 local list_of_funcs = {
          -- { official function name , alias }

          -- general assertions
    2     { 'assertEquals'            , 'assert_equals' },
    2     { 'assertItemsEquals'       , 'assert_items_equals' },
    2     { 'assertNotEquals'         , 'assert_not_equals' },
    2     { 'assertAlmostEquals'      , 'assert_almost_equals' },
    2     { 'assertNotAlmostEquals'   , 'assert_not_almost_equals' },
    2     { 'assertEvalToTrue'        , 'assert_eval_to_true' },
    2     { 'assertEvalToFalse'       , 'assert_eval_to_false' },
    2     { 'assertStrContains'       , 'assert_str_contains' },
    2     { 'assertStrIContains'      , 'assert_str_icontains' },
    2     { 'assertNotStrContains'    , 'assert_not_str_contains' },
    2     { 'assertNotStrIContains'   , 'assert_not_str_icontains' },
    2     { 'assertStrMatches'        , 'assert_str_matches' },
    2     { 'assertError'             , 'assert_error' },
    2     { 'assertErrorMsgEquals'    , 'assert_error_msg_equals' },
    2     { 'assertErrorMsgContains'  , 'assert_error_msg_contains' },
    2     { 'assertErrorMsgMatches'   , 'assert_error_msg_matches' },
    2     { 'assertErrorMsgContentEquals', 'assert_error_msg_content_equals' },
    2     { 'assertIs'                , 'assert_is' },
    2     { 'assertNotIs'             , 'assert_not_is' },
    2     { 'wrapFunctions'           , 'WrapFunctions' },
    2     { 'wrapFunctions'           , 'wrap_functions' },

          -- type assertions: assertIsXXX -> assert_is_xxx
    2     { 'assertIsNumber'          , 'assert_is_number' },
    2     { 'assertIsString'          , 'assert_is_string' },
    2     { 'assertIsTable'           , 'assert_is_table' },
    2     { 'assertIsBoolean'         , 'assert_is_boolean' },
    2     { 'assertIsNil'             , 'assert_is_nil' },
    2     { 'assertIsTrue'            , 'assert_is_true' },
    2     { 'assertIsFalse'           , 'assert_is_false' },
    2     { 'assertIsNaN'             , 'assert_is_nan' },
    2     { 'assertIsInf'             , 'assert_is_inf' },
    2     { 'assertIsPlusInf'         , 'assert_is_plus_inf' },
    2     { 'assertIsMinusInf'        , 'assert_is_minus_inf' },
    2     { 'assertIsPlusZero'        , 'assert_is_plus_zero' },
    2     { 'assertIsMinusZero'       , 'assert_is_minus_zero' },
    2     { 'assertIsFunction'        , 'assert_is_function' },
    2     { 'assertIsThread'          , 'assert_is_thread' },
    2     { 'assertIsUserdata'        , 'assert_is_userdata' },

          -- type assertions: assertIsXXX -> assertXxx
    2     { 'assertIsNumber'          , 'assertNumber' },
    2     { 'assertIsString'          , 'assertString' },
    2     { 'assertIsTable'           , 'assertTable' },
    2     { 'assertIsBoolean'         , 'assertBoolean' },
    2     { 'assertIsNil'             , 'assertNil' },
    2     { 'assertIsTrue'            , 'assertTrue' },
    2     { 'assertIsFalse'           , 'assertFalse' },
    2     { 'assertIsNaN'             , 'assertNaN' },
    2     { 'assertIsInf'             , 'assertInf' },
    2     { 'assertIsPlusInf'         , 'assertPlusInf' },
    2     { 'assertIsMinusInf'        , 'assertMinusInf' },
    2     { 'assertIsPlusZero'        , 'assertPlusZero' },
    2     { 'assertIsMinusZero'       , 'assertMinusZero'},
    2     { 'assertIsFunction'        , 'assertFunction' },
    2     { 'assertIsThread'          , 'assertThread' },
    2     { 'assertIsUserdata'        , 'assertUserdata' },

          -- type assertions: assertIsXXX -> assert_xxx (luaunit v2 compat)
    2     { 'assertIsNumber'          , 'assert_number' },
    2     { 'assertIsString'          , 'assert_string' },
    2     { 'assertIsTable'           , 'assert_table' },
    2     { 'assertIsBoolean'         , 'assert_boolean' },
    2     { 'assertIsNil'             , 'assert_nil' },
    2     { 'assertIsTrue'            , 'assert_true' },
    2     { 'assertIsFalse'           , 'assert_false' },
    2     { 'assertIsNaN'             , 'assert_nan' },
    2     { 'assertIsInf'             , 'assert_inf' },
    2     { 'assertIsPlusInf'         , 'assert_plus_inf' },
    2     { 'assertIsMinusInf'        , 'assert_minus_inf' },
    2     { 'assertIsPlusZero'        , 'assert_plus_zero' },
    2     { 'assertIsMinusZero'       , 'assert_minus_zero' },
    2     { 'assertIsFunction'        , 'assert_function' },
    2     { 'assertIsThread'          , 'assert_thread' },
    2     { 'assertIsUserdata'        , 'assert_userdata' },

          -- type assertions: assertNotIsXXX -> assert_not_is_xxx
    2     { 'assertNotIsNumber'       , 'assert_not_is_number' },
    2     { 'assertNotIsString'       , 'assert_not_is_string' },
    2     { 'assertNotIsTable'        , 'assert_not_is_table' },
    2     { 'assertNotIsBoolean'      , 'assert_not_is_boolean' },
    2     { 'assertNotIsNil'          , 'assert_not_is_nil' },
    2     { 'assertNotIsTrue'         , 'assert_not_is_true' },
    2     { 'assertNotIsFalse'        , 'assert_not_is_false' },
    2     { 'assertNotIsNaN'          , 'assert_not_is_nan' },
    2     { 'assertNotIsInf'          , 'assert_not_is_inf' },
    2     { 'assertNotIsPlusInf'      , 'assert_not_plus_inf' },
    2     { 'assertNotIsMinusInf'     , 'assert_not_minus_inf' },
    2     { 'assertNotIsPlusZero'     , 'assert_not_plus_zero' },
    2     { 'assertNotIsMinusZero'    , 'assert_not_minus_zero' },
    2     { 'assertNotIsFunction'     , 'assert_not_is_function' },
    2     { 'assertNotIsThread'       , 'assert_not_is_thread' },
    2     { 'assertNotIsUserdata'     , 'assert_not_is_userdata' },

          -- type assertions: assertNotIsXXX -> assertNotXxx (luaunit v2 compat)
    2     { 'assertNotIsNumber'       , 'assertNotNumber' },
    2     { 'assertNotIsString'       , 'assertNotString' },
    2     { 'assertNotIsTable'        , 'assertNotTable' },
    2     { 'assertNotIsBoolean'      , 'assertNotBoolean' },
    2     { 'assertNotIsNil'          , 'assertNotNil' },
    2     { 'assertNotIsTrue'         , 'assertNotTrue' },
    2     { 'assertNotIsFalse'        , 'assertNotFalse' },
    2     { 'assertNotIsNaN'          , 'assertNotNaN' },
    2     { 'assertNotIsInf'          , 'assertNotInf' },
    2     { 'assertNotIsPlusInf'      , 'assertNotPlusInf' },
    2     { 'assertNotIsMinusInf'     , 'assertNotMinusInf' },
    2     { 'assertNotIsPlusZero'     , 'assertNotPlusZero' },
    2     { 'assertNotIsMinusZero'    , 'assertNotMinusZero' },
    2     { 'assertNotIsFunction'     , 'assertNotFunction' },
    2     { 'assertNotIsThread'       , 'assertNotThread' },
    2     { 'assertNotIsUserdata'     , 'assertNotUserdata' },

          -- type assertions: assertNotIsXXX -> assert_not_xxx
    2     { 'assertNotIsNumber'       , 'assert_not_number' },
    2     { 'assertNotIsString'       , 'assert_not_string' },
    2     { 'assertNotIsTable'        , 'assert_not_table' },
    2     { 'assertNotIsBoolean'      , 'assert_not_boolean' },
    2     { 'assertNotIsNil'          , 'assert_not_nil' },
    2     { 'assertNotIsTrue'         , 'assert_not_true' },
    2     { 'assertNotIsFalse'        , 'assert_not_false' },
    2     { 'assertNotIsNaN'          , 'assert_not_nan' },
    2     { 'assertNotIsInf'          , 'assert_not_inf' },
    2     { 'assertNotIsPlusInf'      , 'assert_not_plus_inf' },
    2     { 'assertNotIsMinusInf'     , 'assert_not_minus_inf' },
    2     { 'assertNotIsPlusZero'     , 'assert_not_plus_zero' },
    2     { 'assertNotIsMinusZero'    , 'assert_not_minus_zero' },
    2     { 'assertNotIsFunction'     , 'assert_not_function' },
    2     { 'assertNotIsThread'       , 'assert_not_thread' },
    2     { 'assertNotIsUserdata'     , 'assert_not_userdata' },

          -- all assertions with Coroutine duplicate Thread assertions
    2     { 'assertIsThread'          , 'assertIsCoroutine' },
    2     { 'assertIsThread'          , 'assertCoroutine' },
    2     { 'assertIsThread'          , 'assert_is_coroutine' },
    2     { 'assertIsThread'          , 'assert_coroutine' },
    2     { 'assertNotIsThread'       , 'assertNotIsCoroutine' },
    2     { 'assertNotIsThread'       , 'assertNotCoroutine' },
    2     { 'assertNotIsThread'       , 'assert_not_is_coroutine' },
    2     { 'assertNotIsThread'       , 'assert_not_coroutine' },
    2 }

      -- Create all aliases in M
  252 for _,v in ipairs( list_of_funcs ) do
  250     local funcname, alias = v[1], v[2]
  250     M[alias] = M[funcname]

  250     if EXPORT_ASSERT_TO_GLOBALS then
****0         _G[funcname] = M[funcname]
****0         _G[alias] = M[funcname]
          end
      end

      ----------------------------------------------------------------
      --
      --                     Outputters
      --
      ----------------------------------------------------------------

      -- A common "base" class for outputters
      -- For concepts involved (class inheritance) see http://www.lua.org/pil/16.2.html

    2 local genericOutput = { __class__ = 'genericOutput' } -- class
    2 local genericOutput_MT = { __index = genericOutput } -- metatable
    2 M.genericOutput = genericOutput -- publish, so that custom classes may derive from it

    4 function genericOutput.new(runner, default_verbosity)
          -- runner is the "parent" object controlling the output, usually a LuaUnit instance
    8     local t = { runner = runner }
    8     if runner then
    2         t.result = runner.result
    2         t.verbosity = runner.verbosity or default_verbosity
    2         t.fname = runner.fname
          else
    6         t.verbosity = default_verbosity
          end
    8     return setmetatable( t, genericOutput_MT)
      end

      -- abstract ("empty") methods
    2 function genericOutput:startSuite() end
    4 function genericOutput:startClass(className) end
    2 function genericOutput:startTest(testName) end
    2 function genericOutput:addStatus(node) end
    2 function genericOutput:endTest(node) end
    4 function genericOutput:endClass() end
    2 function genericOutput:endSuite() end


      ----------------------------------------------------------------
      --                     class TapOutput
      ----------------------------------------------------------------

    2 local TapOutput = genericOutput.new() -- derived class
    2 local TapOutput_MT = { __index = TapOutput } -- metatable
    2 TapOutput.__class__ = 'TapOutput'

          -- For a good reference for TAP format, check: http://testanything.org/tap-specification.html

    4     function TapOutput.new(runner)
****0         local t = genericOutput.new(runner, M.VERBOSITY_LOW)
****0         return setmetatable( t, TapOutput_MT)
          end
    4     function TapOutput:startSuite()
****0         print("1.."..self.result.testCount)
****0         print('# Started on '..self.result.startDate)
          end
    4     function TapOutput:startClass(className)
****0         if className ~= '[TestFunctions]' then
****0             print('# Starting class: '..className)
              end
          end

    4     function TapOutput:addStatus( node )
****0         io.stdout:write("not ok ", self.result.currentTestNumber, "\t", node.testName, "\n")
****0         if self.verbosity > M.VERBOSITY_LOW then
****0            print( prefixString( '#   ', node.msg ) )
              end
****0         if self.verbosity > M.VERBOSITY_DEFAULT then
****0            print( prefixString( '#   ', node.stackTrace ) )
              end
          end

    4     function TapOutput:endTest( node )
****0         if node:isPassed() then
****0             io.stdout:write("ok     ", self.result.currentTestNumber, "\t", node.testName, "\n")
              end
          end

    4     function TapOutput:endSuite()
****0         print( '# '..M.LuaUnit.statusLine( self.result ) )
****0         return self.result.notPassedCount
          end


      -- class TapOutput end

      ----------------------------------------------------------------
      --                     class JUnitOutput
      ----------------------------------------------------------------

      -- See directory junitxml for more information about the junit format
    2 local JUnitOutput = genericOutput.new() -- derived class
    2 local JUnitOutput_MT = { __index = JUnitOutput } -- metatable
    2 JUnitOutput.__class__ = 'JUnitOutput'

    4     function JUnitOutput.new(runner)
****0         local t = genericOutput.new(runner, M.VERBOSITY_LOW)
****0         t.testList = {}
****0         return setmetatable( t, JUnitOutput_MT )
          end

    4     function JUnitOutput:startSuite()
              -- open xml file early to deal with errors
****0         if self.fname == nil then
****0             error('With Junit, an output filename must be supplied with --name!')
              end
****0         if string.sub(self.fname,-4) ~= '.xml' then
****0             self.fname = self.fname..'.xml'
              end
****0         self.fd = io.open(self.fname, "w")
****0         if self.fd == nil then
****0             error("Could not open file for writing: "..self.fname)
              end

****0         print('# XML output to '..self.fname)
****0         print('# Started on '..self.result.startDate)
          end
    4     function JUnitOutput:startClass(className)
****0         if className ~= '[TestFunctions]' then
****0             print('# Starting class: '..className)
              end
          end
    4     function JUnitOutput:startTest(testName)
****0         print('# Starting test: '..testName)
          end

    4     function JUnitOutput:addStatus( node )
****0         if node:isFailure() then
****0             print( '#   Failure: ' .. prefixString( '#   ', node.msg ):sub(4, nil) )
                  -- print('# ' .. node.stackTrace)
****0         elseif node:isError() then
****0             print( '#   Error: ' .. prefixString( '#   '  , node.msg ):sub(4, nil) )
                  -- print('# ' .. node.stackTrace)
              end
          end

    4     function JUnitOutput:endSuite()
****0         print( '# '..M.LuaUnit.statusLine(self.result))

              -- XML file writing
****0         self.fd:write('<?xml version="1.0" encoding="UTF-8" ?>\n')
****0         self.fd:write('<testsuites>\n')
****0         self.fd:write(string.format(
                  '    <testsuite name="LuaUnit" id="00001" package="" hostname="localhost" tests="%d" timestamp="%s" time="%0.3f" errors="%d" failures="%d">\n',
****0             self.result.runCount, self.result.startIsodate, self.result.duration, self.result.errorCount, self.result.failureCount ))
****0         self.fd:write("        <properties>\n")
****0         self.fd:write(string.format('            <property name="Lua Version" value="%s"/>\n', _VERSION ) )
****0         self.fd:write(string.format('            <property name="LuaUnit Version" value="%s"/>\n', M.VERSION) )
              -- XXX please include system name and version if possible
****0         self.fd:write("        </properties>\n")

****0         for i,node in ipairs(self.result.tests) do
****0             self.fd:write(string.format('        <testcase classname="%s" name="%s" time="%0.3f">\n',
****0                 node.className, node.testName, node.duration ) )
****0             if node:isNotPassed() then
****0                 self.fd:write(node:statusXML())
                  end
****0             self.fd:write('        </testcase>\n')
              end

              -- Next two lines are needed to validate junit ANT xsd, but really not useful in general:
****0         self.fd:write('    <system-out/>\n')
****0         self.fd:write('    <system-err/>\n')

****0         self.fd:write('    </testsuite>\n')
****0         self.fd:write('</testsuites>\n')
****0         self.fd:close()
****0         return self.result.notPassedCount
          end


      -- class TapOutput end

      ----------------------------------------------------------------
      --                     class TextOutput
      ----------------------------------------------------------------

      --[[

      -- Python Non verbose:

      For each test: . or F or E

      If some failed tests:
          ==============
          ERROR / FAILURE: TestName (testfile.testclass)
          ---------
          Stack trace


      then --------------
      then "Ran x tests in 0.000s"
      then OK or FAILED (failures=1, error=1)

      -- Python Verbose:
      testname (filename.classname) ... ok
      testname (filename.classname) ... FAIL
      testname (filename.classname) ... ERROR

      then --------------
      then "Ran x tests in 0.000s"
      then OK or FAILED (failures=1, error=1)

      -- Ruby:
      Started
       .
       Finished in 0.002695 seconds.

       1 tests, 2 assertions, 0 failures, 0 errors

      -- Ruby:
      >> ruby tc_simple_number2.rb
      Loaded suite tc_simple_number2
      Started
      F..
      Finished in 0.038617 seconds.

        1) Failure:
      test_failure(TestSimpleNumber) [tc_simple_number2.rb:16]:
      Adding doesn't work.
      <3> expected but was
      <4>.

      3 tests, 4 assertions, 1 failures, 0 errors

      -- Java Junit
      .......F.
      Time: 0,003
      There was 1 failure:
      1) testCapacity(junit.samples.VectorTest)junit.framework.AssertionFailedError
          at junit.samples.VectorTest.testCapacity(VectorTest.java:87)
          at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
          at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
          at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

      FAILURES!!!
      Tests run: 8,  Failures: 1,  Errors: 0


      -- Maven

      # mvn test
      -------------------------------------------------------
       T E S T S
      -------------------------------------------------------
      Running math.AdditionTest
      Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed:
      0.03 sec <<< FAILURE!

      Results :

      Failed tests:
        testLireSymbole(math.AdditionTest)

      Tests run: 2, Failures: 1, Errors: 0, Skipped: 0


      -- LuaUnit
      ---- non verbose
      * display . or F or E when running tests
      ---- verbose
      * display test name + ok/fail
      ----
      * blank line
      * number) ERROR or FAILURE: TestName
         Stack trace
      * blank line
      * number) ERROR or FAILURE: TestName
         Stack trace

      then --------------
      then "Ran x tests in 0.000s (%d not selected, %d skipped)"
      then OK or FAILED (failures=1, error=1)


      ]]

    2 local TextOutput = genericOutput.new() -- derived class
    2 local TextOutput_MT = { __index = TextOutput } -- metatable
    2 TextOutput.__class__ = 'TextOutput'

    4     function TextOutput.new(runner)
    2         local t = genericOutput.new(runner, M.VERBOSITY_DEFAULT)
    2         t.errorList = {}
    2         return setmetatable( t, TextOutput_MT )
          end

    4     function TextOutput:startSuite()
    2         if self.verbosity > M.VERBOSITY_DEFAULT then
****0             print( 'Started on '.. self.result.startDate )
              end
          end

    4     function TextOutput:startTest(testName)
   32         if self.verbosity > M.VERBOSITY_DEFAULT then
****0             io.stdout:write( "    ", self.result.currentNode.testName, " ... " )
              end
          end

    4     function TextOutput:endTest( node )
   32         if node:isPassed() then
   32             if self.verbosity > M.VERBOSITY_DEFAULT then
****0                 io.stdout:write("Ok\n")
                  else
   32                 io.stdout:write(".")
   32                 io.stdout:flush()
                  end
              else
****0             if self.verbosity > M.VERBOSITY_DEFAULT then
****0                 print( node.status )
****0                 print( node.msg )
                      --[[
                      -- find out when to do this:
                      if self.verbosity > M.VERBOSITY_DEFAULT then
                          print( node.stackTrace )
                      end
                      ]]
                  else
                      -- write only the first character of status
****0                 io.stdout:write(string.sub(node.status, 1, 1))
****0                 io.stdout:flush()
                  end
              end
          end

    4     function TextOutput:displayOneFailedTest( index, fail )
****0         print(index..") "..fail.testName )
****0         print( fail.msg )
****0         print( fail.stackTrace )
****0         print()
          end

    4     function TextOutput:displayFailedTests()
    2         if self.result.notPassedCount ~= 0 then
****0             print("Failed tests:")
****0             print("-------------")
****0             for i, v in ipairs(self.result.notPassed) do
****0                 self:displayOneFailedTest(i, v)
                  end
              end
          end

    4     function TextOutput:endSuite()
    2         if self.verbosity > M.VERBOSITY_DEFAULT then
****0             print("=========================================================")
              else
    2             print()
              end
    2         self:displayFailedTests()
    2         print( M.LuaUnit.statusLine( self.result ) )
    2         if self.result.notPassedCount == 0 then
    2             print('OK')
              end
          end

      -- class TextOutput end


      ----------------------------------------------------------------
      --                     class NilOutput
      ----------------------------------------------------------------

      local function nopCallable()
          --print(42)
****0     return nopCallable
      end

    2 local NilOutput = { __class__ = 'NilOuptut' } -- class
    2 local NilOutput_MT = { __index = nopCallable } -- metatable

    4 function NilOutput.new(runner)
****0     return setmetatable( { __class__ = 'NilOutput' }, NilOutput_MT )
      end

      ----------------------------------------------------------------
      --
      --                     class LuaUnit
      --
      ----------------------------------------------------------------

    2 M.LuaUnit = {
    2     outputType = TextOutput,
    2     verbosity = M.VERBOSITY_DEFAULT,
    2     __class__ = 'LuaUnit'
    2 }
    2 local LuaUnit_MT = { __index = M.LuaUnit }

    2 if EXPORT_ASSERT_TO_GLOBALS then
****0     LuaUnit = M.LuaUnit
      end

    4     function M.LuaUnit.new()
    2         return setmetatable( {}, LuaUnit_MT )
          end

          -----------------[[ Utility methods ]]---------------------

    4     function M.LuaUnit.asFunction(aObject)
              -- return "aObject" if it is a function, and nil otherwise
   64         if 'function' == type(aObject) then
   64             return aObject
              end
          end

    4     function M.LuaUnit.splitClassMethod(someName)
              --[[
              Return a pair of className, methodName strings for a name in the form
              "class.method". If no class part (or separator) is found, will return
              nil, someName instead (the latter being unchanged).

              This convention thus also replaces the older isClassMethod() test:
              You just have to check for a non-nil className (return) value.
              ]]
   32         local separator = string.find(someName, '.', 1, true)
   32         if separator then
****0             return someName:sub(1, separator - 1), someName:sub(separator + 1)
              end
   32         return nil, someName
          end

    4     function M.LuaUnit.isMethodTestName( s )
              -- return true is the name matches the name of a test method
              -- default rule is that is starts with 'Test' or with 'test'
****0         return string.sub(s, 1, 4):lower() == 'test'
          end

    4     function M.LuaUnit.isTestName( s )
              -- return true is the name matches the name of a test
              -- default rule is that is starts with 'Test' or with 'test'
  118         return string.sub(s, 1, 4):lower() == 'test'
          end

    4     function M.LuaUnit.collectTests()
              -- return a list of all test names in the global namespace
              -- that match LuaUnit.isTestName

    2         local testNames = {}
  120         for k, _ in pairs(_G) do
  118             if type(k) == "string" and M.LuaUnit.isTestName( k ) then
   32                 table.insert( testNames , k )
                  end
              end
    2         table.sort( testNames )
    2         return testNames
          end

    4     function M.LuaUnit.parseCmdLine( cmdLine )
              -- parse the command line
              -- Supported command line parameters:
              -- --verbose, -v: increase verbosity
              -- --quiet, -q: silence output
              -- --error, -e: treat errors as fatal (quit program)
              -- --output, -o, + name: select output type
              -- --pattern, -p, + pattern: run test matching pattern, may be repeated
              -- --exclude, -x, + pattern: run test not matching pattern, may be repeated
              -- --shuffle, -s, : shuffle tests before reunning them
              -- --name, -n, + fname: name of output file for junit, default to stdout
              -- --repeat, -r, + num: number of times to execute each test
              -- [testnames, ...]: run selected test names
              --
              -- Returns a table with the following fields:
              -- verbosity: nil, M.VERBOSITY_DEFAULT, M.VERBOSITY_QUIET, M.VERBOSITY_VERBOSE
              -- output: nil, 'tap', 'junit', 'text', 'nil'
              -- testNames: nil or a list of test names to run
              -- exeRepeat: num or 1
              -- pattern: nil or a list of patterns
              -- exclude: nil or a list of patterns

    2         local result, state = {}, nil
    2         local SET_OUTPUT = 1
    2         local SET_PATTERN = 2
    2         local SET_EXCLUDE = 3
    2         local SET_FNAME = 4
    2         local SET_REPEAT = 5

    2         if cmdLine == nil then
****0             return result
              end

              local function parseOption( option )
****0             if option == '--help' or option == '-h' then
****0                 result['help'] = true
****0                 return
****0             elseif option == '--version' then
****0                 result['version'] = true
****0                 return
****0             elseif option == '--verbose' or option == '-v' then
****0                 result['verbosity'] = M.VERBOSITY_VERBOSE
****0                 return
****0             elseif option == '--quiet' or option == '-q' then
****0                 result['verbosity'] = M.VERBOSITY_QUIET
****0                 return
****0             elseif option == '--error' or option == '-e' then
****0                 result['quitOnError'] = true
****0                 return
****0             elseif option == '--failure' or option == '-f' then
****0                 result['quitOnFailure'] = true
****0                 return
****0             elseif option == '--shuffle' or option == '-s' then
****0                 result['shuffle'] = true
****0                 return
****0             elseif option == '--output' or option == '-o' then
****0                 state = SET_OUTPUT
****0                 return state
****0             elseif option == '--name' or option == '-n' then
****0                 state = SET_FNAME
****0                 return state
****0             elseif option == '--repeat' or option == '-r' then
****0                 state = SET_REPEAT
****0                 return state
****0             elseif option == '--pattern' or option == '-p' then
****0                 state = SET_PATTERN
****0                 return state
****0             elseif option == '--exclude' or option == '-x' then
****0                 state = SET_EXCLUDE
****0                 return state
                  end
****0             error('Unknown option: '..option,3)
              end

              local function setArg( cmdArg, state )
****0             if state == SET_OUTPUT then
****0                 result['output'] = cmdArg
****0                 return
****0             elseif state == SET_FNAME then
****0                 result['fname'] = cmdArg
****0                 return
****0             elseif state == SET_REPEAT then
****0                 result['exeRepeat'] = tonumber(cmdArg)
****0                                      or error('Malformed -r argument: '..cmdArg)
****0                 return
****0             elseif state == SET_PATTERN then
****0                 if result['pattern'] then
****0                     table.insert( result['pattern'], cmdArg )
                      else
****0                     result['pattern'] = { cmdArg }
                      end
****0                 return
****0             elseif state == SET_EXCLUDE then
****0                 local notArg = '!'..cmdArg
****0                 if result['pattern'] then
****0                     table.insert( result['pattern'],  notArg )
                      else
****0                     result['pattern'] = { notArg }
                      end
****0                 return
                  end
****0             error('Unknown parse state: '.. state)
              end


    2         for i, cmdArg in ipairs(cmdLine) do
****0             if state ~= nil then
****0                 setArg( cmdArg, state, result )
****0                 state = nil
                  else
****0                 if cmdArg:sub(1,1) == '-' then
****0                     state = parseOption( cmdArg )
                      else
****0                     if result['testNames'] then
****0                         table.insert( result['testNames'], cmdArg )
                          else
****0                         result['testNames'] = { cmdArg }
                          end
                      end
                  end
              end

    2         if result['help'] then
****0             M.LuaUnit.help()
              end

    2         if result['version'] then
****0             M.LuaUnit.version()
              end

    2         if state ~= nil then
****0             error('Missing argument after '..cmdLine[ #cmdLine ],2 )
              end

    2         return result
          end

    4     function M.LuaUnit.help()
****0         print(M.USAGE)
****0         os.exit(0)
          end

    4     function M.LuaUnit.version()
****0         print('LuaUnit v'..M.VERSION..' by Philippe Fremy <phil@freehackers.org>')
****0         os.exit(0)
          end

      ----------------------------------------------------------------
      --                     class NodeStatus
      ----------------------------------------------------------------

    2     local NodeStatus = { __class__ = 'NodeStatus' } -- class
    2     local NodeStatus_MT = { __index = NodeStatus } -- metatable
    2     M.NodeStatus = NodeStatus

          -- values of status
    2     NodeStatus.PASS  = 'PASS'
    2     NodeStatus.FAIL  = 'FAIL'
    2     NodeStatus.ERROR = 'ERROR'

    4     function NodeStatus.new( number, testName, className )
   32         local t = { number = number, testName = testName, className = className }
   32         setmetatable( t, NodeStatus_MT )
   32         t:pass()
   32         return t
          end

    4     function NodeStatus:pass()
   32         self.status = self.PASS
              -- useless but we know it's the field we want to use
   32         self.msg = nil
   32         self.stackTrace = nil
          end

    2     function NodeStatus:fail(msg, stackTrace)
****0         self.status = self.FAIL
****0         self.msg = msg
****0         self.stackTrace = stackTrace
          end

    4     function NodeStatus:error(msg, stackTrace)
****0         self.status = self.ERROR
****0         self.msg = msg
****0         self.stackTrace = stackTrace
          end

    4     function NodeStatus:isPassed()
   96         return self.status == NodeStatus.PASS
          end

    4     function NodeStatus:isNotPassed()
              -- print('hasFailure: '..prettystr(self))
   32         return self.status ~= NodeStatus.PASS
          end

    4     function NodeStatus:isFailure()
****0         return self.status == NodeStatus.FAIL
          end

    4     function NodeStatus:isError()
****0         return self.status == NodeStatus.ERROR
          end

    4     function NodeStatus:statusXML()
****0         if self:isError() then
****0             return table.concat(
****0                 {'            <error type="', xmlEscape(self.msg), '">\n',
****0                  '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                       ']]></error>\n'})
****0         elseif self:isFailure() then
****0             return table.concat(
****0                 {'            <failure type="', xmlEscape(self.msg), '">\n',
****0                  '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                       ']]></failure>\n'})
              end
****0         return '            <passed/>\n' -- (not XSD-compliant! normally shouldn't get here)
          end

          --------------[[ Output methods ]]-------------------------

          local function conditional_plural(number, singular)
              -- returns a grammatically well-formed string "%d <singular/plural>"
    2         local suffix = ''
    2         if number ~= 1 then -- use plural
    2             suffix = (singular:sub(-2) == 'ss') and 'es' or 's'
              end
    2         return string.format('%d %s%s', number, singular, suffix)
          end

    4     function M.LuaUnit.statusLine(result)
              -- return status line string according to results
    2         local s = {
    4             string.format('Ran %d tests in %0.3f seconds',
    2                           result.runCount, result.duration),
    2             conditional_plural(result.passedCount, 'success'),
    2         }
    2         if result.notPassedCount > 0 then
****0             if result.failureCount > 0 then
****0                 table.insert(s, conditional_plural(result.failureCount, 'failure'))
                  end
****0             if result.errorCount > 0 then
****0                 table.insert(s, conditional_plural(result.errorCount, 'error'))
                  end
              else
    2             table.insert(s, '0 failures')
              end
    2         if result.nonSelectedCount > 0 then
****0             table.insert(s, string.format("%d non-selected", result.nonSelectedCount))
              end
    2         return table.concat(s, ', ')
          end

    4     function M.LuaUnit:startSuite(testCount, nonSelectedCount)
    2         self.result = {
    2             testCount = testCount,
    2             nonSelectedCount = nonSelectedCount,
    2             passedCount = 0,
    2             runCount = 0,
    2             currentTestNumber = 0,
    2             currentClassName = "",
    2             currentNode = nil,
    2             suiteStarted = true,
    2             startTime = os.clock(),
    2             startDate = os.date(os.getenv('LUAUNIT_DATEFMT')),
    2             startIsodate = os.date('%Y-%m-%dT%H:%M:%S'),
    2             patternIncludeFilter = self.patternIncludeFilter,
    2             tests = {},
    2             failures = {},
    2             errors = {},
    2             notPassed = {},
    2         }

    2         self.outputType = self.outputType or TextOutput
    2         self.output = self.outputType.new(self)
    2         self.output:startSuite()
          end

    4     function M.LuaUnit:startClass( className )
    2         self.result.currentClassName = className
    2         self.output:startClass( className )
          end

    4     function M.LuaUnit:startTest( testName  )
   32         self.result.currentTestNumber = self.result.currentTestNumber + 1
   32         self.result.runCount = self.result.runCount + 1
   64         self.result.currentNode = NodeStatus.new(
   32             self.result.currentTestNumber,
   32             testName,
   32             self.result.currentClassName
   64         )
   32         self.result.currentNode.startTime = os.clock()
   32         table.insert( self.result.tests, self.result.currentNode )
   32         self.output:startTest( testName )
          end

    4     function M.LuaUnit:addStatus( err )
              -- "err" is expected to be a table / result from protectedCall()
   32         if err.status == NodeStatus.PASS then
   32             return
              end

****0         local node = self.result.currentNode

              --[[ As a first approach, we will report only one error or one failure for one test.

              However, we can have the case where the test is in failure, and the teardown is in error.
              In such case, it's a good idea to report both a failure and an error in the test suite. This is
              what Python unittest does for example. However, it mixes up counts so need to be handled carefully: for
              example, there could be more (failures + errors) count that tests. What happens to the current node ?

              We will do this more intelligent version later.
              ]]

              -- if the node is already in failure/error, just don't report the new error (see above)
****0         if node.status ~= NodeStatus.PASS then
****0             return
              end

****0         if err.status == NodeStatus.FAIL then
****0             node:fail( err.msg, err.trace )
****0             table.insert( self.result.failures, node )
****0         elseif err.status == NodeStatus.ERROR then
****0             node:error( err.msg, err.trace )
****0             table.insert( self.result.errors, node )
              end

****0         if node:isFailure() or node:isError() then
                  -- add to the list of failed tests (gets printed separately)
****0             table.insert( self.result.notPassed, node )
              end
****0         self.output:addStatus( node )
          end

    4     function M.LuaUnit:endTest()
   32         local node = self.result.currentNode
              -- print( 'endTest() '..prettystr(node))
              -- print( 'endTest() '..prettystr(node:isNotPassed()))
   32         node.duration = os.clock() - node.startTime
   32         node.startTime = nil
   32         self.output:endTest( node )

   32         if node:isPassed() then
   32             self.result.passedCount = self.result.passedCount + 1
****0         elseif node:isError() then
****0             if self.quitOnError or self.quitOnFailure then
                      -- Runtime error - abort test execution as requested by
                      -- "--error" option. This is done by setting a special
                      -- flag that gets handled in runSuiteByInstances().
****0                 print("\nERROR during LuaUnit test execution:\n" .. node.msg)
****0                 self.result.aborted = true
                  end
****0         elseif node:isFailure() then
****0             if self.quitOnFailure then
                      -- Failure - abort test execution as requested by
                      -- "--failure" option. This is done by setting a special
                      -- flag that gets handled in runSuiteByInstances().
****0                 print("\nFailure during LuaUnit test execution:\n" .. node.msg)
****0                 self.result.aborted = true
                  end
              end
   32         self.result.currentNode = nil
          end

    4     function M.LuaUnit:endClass()
    2         self.output:endClass()
          end

    4     function M.LuaUnit:endSuite()
    2         if self.result.suiteStarted == false then
****0             error('LuaUnit:endSuite() -- suite was already ended' )
              end
    2         self.result.duration = os.clock()-self.result.startTime
    2         self.result.suiteStarted = false

              -- Expose test counts for outputter's endSuite(). This could be managed
              -- internally instead, but unit tests (and existing use cases) might
              -- rely on these fields being present.
    2         self.result.notPassedCount = #self.result.notPassed
    2         self.result.failureCount = #self.result.failures
    2         self.result.errorCount = #self.result.errors

    2         self.output:endSuite()
          end

    4     function M.LuaUnit:setOutputType(outputType)
              -- default to text
              -- tap produces results according to TAP format
****0         if outputType:upper() == "NIL" then
****0             self.outputType = NilOutput
****0             return
              end
****0         if outputType:upper() == "TAP" then
****0             self.outputType = TapOutput
****0             return
              end
****0         if outputType:upper() == "JUNIT" then
****0             self.outputType = JUnitOutput
****0             return
              end
****0         if outputType:upper() == "TEXT" then
****0             self.outputType = TextOutput
****0             return
              end
****0         error( 'No such format: '..outputType,2)
          end

          --------------[[ Runner ]]-----------------

    4     function M.LuaUnit:protectedCall(classInstance, methodInstance, prettyFuncName)
              -- if classInstance is nil, this is just a function call
              -- else, it's method of a class being called.

              local function err_handler(e)
                  -- transform error into a table, adding the traceback information
****0             return {
                      status = NodeStatus.ERROR,
                      msg = e,
****0                 trace = string.sub(debug.traceback("", 3), 2)
                  }
              end

              local ok, err
   32         if classInstance then
                  -- stupid Lua < 5.2 does not allow xpcall with arguments so let's use a workaround
****0             ok, err = xpcall( function () methodInstance(classInstance) end, err_handler )
              else
   64             ok, err = xpcall( function () methodInstance() end, err_handler )
              end
   32         if ok then
   32             return {status = NodeStatus.PASS}
              end

              local iter_msg
****0         iter_msg = self.exeRepeat and 'iteration '..self.currentCount

****0         err.msg, err.status = M.adjust_err_msg_with_iter( err.msg, iter_msg )

****0         if err.status == NodeStatus.PASS then
****0             err.trace = nil
****0             return err
              end

              -- reformat / improve the stack trace
****0         if prettyFuncName then -- we do have the real method name
****0             err.trace = err.trace:gsub("in (%a+) 'methodInstance'", "in %1 '"..prettyFuncName.."'")
              end
****0         if STRIP_LUAUNIT_FROM_STACKTRACE then
****0             err.trace = stripLuaunitTrace(err.trace)
              end

****0         return err -- return the error "object" (table)
          end


    4     function M.LuaUnit:execOneFunction(className, methodName, classInstance, methodInstance)
              -- When executing a test function, className and classInstance must be nil
              -- When executing a class method, all parameters must be set

   32         if type(methodInstance) ~= 'function' then
****0             error( tostring(methodName)..' must be a function, not '..type(methodInstance))
              end

              local prettyFuncName
   32         if className == nil then
   32             className = '[TestFunctions]'
   32             prettyFuncName = methodName
              else
****0             prettyFuncName = className..'.'..methodName
              end

   32         if self.lastClassName ~= className then
    2             if self.lastClassName ~= nil then
****0                 self:endClass()
                  end
    2             self:startClass( className )
    2             self.lastClassName = className
              end

   32         self:startTest(prettyFuncName)

   32         local node = self.result.currentNode
   64         for iter_n = 1, self.exeRepeat or 1 do
   32             if node:isNotPassed() then
                      break
                  end
   32             self.currentCount = iter_n

                  -- run setUp first (if any)
   32             if classInstance then
****0                 local func = self.asFunction( classInstance.setUp ) or
****0                              self.asFunction( classInstance.Setup ) or
****0                              self.asFunction( classInstance.setup ) or
****0                              self.asFunction( classInstance.SetUp )
****0                 if func then
****0                     self:addStatus(self:protectedCall(classInstance, func, className..'.setUp'))
                      end
                  end

                  -- run testMethod()
   32             if node:isPassed() then
   32                 self:addStatus(self:protectedCall(classInstance, methodInstance, prettyFuncName))
                  end

                  -- lastly, run tearDown (if any)
   32             if classInstance then
****0                 local func = self.asFunction( classInstance.tearDown ) or
****0                              self.asFunction( classInstance.TearDown ) or
****0                              self.asFunction( classInstance.teardown ) or
****0                              self.asFunction( classInstance.Teardown )
****0                 if func then
****0                     self:addStatus(self:protectedCall(classInstance, func, className..'.tearDown'))
                      end
                  end
              end

   32         self:endTest()
          end

    4     function M.LuaUnit.expandOneClass( result, className, classInstance )
              --[[
              Input: a list of { name, instance }, a class name, a class instance
              Ouptut: modify result to add all test method instance in the form:
              { className.methodName, classInstance }
              ]]
****0         for methodName, methodInstance in sortedPairs(classInstance) do
****0             if M.LuaUnit.asFunction(methodInstance) and M.LuaUnit.isMethodTestName( methodName ) then
****0                 table.insert( result, { className..'.'..methodName, classInstance } )
                  end
              end
          end

    4     function M.LuaUnit.expandClasses( listOfNameAndInst )
              --[[
              -- expand all classes (provided as {className, classInstance}) to a list of {className.methodName, classInstance}
              -- functions and methods remain untouched

              Input: a list of { name, instance }

              Output:
              * { function name, function instance } : do nothing
              * { class.method name, class instance }: do nothing
              * { class name, class instance } : add all method names in the form of (className.methodName, classInstance)
              ]]
    2         local result = {}

   34         for i,v in ipairs( listOfNameAndInst ) do
   32             local name, instance = v[1], v[2]
   32             if M.LuaUnit.asFunction(instance) then
   32                 table.insert( result, { name, instance } )
                  else
****0                 if type(instance) ~= 'table' then
****0                     error( 'Instance must be a table or a function, not a '..type(instance)..' with value '..prettystr(instance))
                      end
****0                 local className, methodName = M.LuaUnit.splitClassMethod( name )
****0                 if className then
****0                     local methodInstance = instance[methodName]
****0                     if methodInstance == nil then
****0                         error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                          end
****0                     table.insert( result, { name, instance } )
                      else
****0                     M.LuaUnit.expandOneClass( result, name, instance )
                      end
                  end
              end

    2         return result
          end

    4     function M.LuaUnit.applyPatternFilter( patternIncFilter, listOfNameAndInst )
    2         local included, excluded = {}, {}
   34         for i, v in ipairs( listOfNameAndInst ) do
                  -- local name, instance = v[1], v[2]
   32             if  patternFilter( patternIncFilter, v[1] ) then
   32                 table.insert( included, v )
                  else
****0                 table.insert( excluded, v )
                  end
              end
    2         return included, excluded
          end

    4     function M.LuaUnit:runSuiteByInstances( listOfNameAndInst )
              --[[ Run an explicit list of tests. Each item of the list must be one of:
              * { function name, function instance }
              * { class name, class instance }
              * { class.method name, class instance }
              ]]

    2         local expandedList = self.expandClasses( listOfNameAndInst )
    2         if self.shuffle then
****0             randomizeTable( expandedList )
              end
    4         local filteredList, filteredOutList = self.applyPatternFilter(
    2             self.patternIncludeFilter, expandedList )

    2         self:startSuite( #filteredList, #filteredOutList )

   34         for i,v in ipairs( filteredList ) do
   32             local name, instance = v[1], v[2]
   32             if M.LuaUnit.asFunction(instance) then
   32                 self:execOneFunction( nil, name, nil, instance )
                  else
                      -- expandClasses() should have already taken care of sanitizing the input
****0                 assert( type(instance) == 'table' )
****0                 local className, methodName = M.LuaUnit.splitClassMethod( name )
****0                 assert( className ~= nil )
****0                 local methodInstance = instance[methodName]
****0                 assert(methodInstance ~= nil)
****0                 self:execOneFunction( className, methodName, instance, methodInstance )
                  end
   32             if self.result.aborted then
                      break -- "--error" or "--failure" option triggered
                  end
              end

    2         if self.lastClassName ~= nil then
    2             self:endClass()
              end

    2         self:endSuite()

    2         if self.result.aborted then
****0             print("LuaUnit ABORTED (as requested by --error or --failure option)")
****0             os.exit(-2)
              end
          end

    4     function M.LuaUnit:runSuiteByNames( listOfName )
              --[[ Run LuaUnit with a list of generic names, coming either from command-line or from global
                  namespace analysis. Convert the list into a list of (name, valid instances (table or function))
                  and calls runSuiteByInstances.
              ]]

              local instanceName, instance
    2         local listOfNameAndInst = {}

   34         for i,name in ipairs( listOfName ) do
   32             local className, methodName = M.LuaUnit.splitClassMethod( name )
   32             if className then
****0                 instanceName = className
****0                 instance = _G[instanceName]

****0                 if instance == nil then
****0                     error( "No such name in global space: "..instanceName )
                      end

****0                 if type(instance) ~= 'table' then
****0                     error( 'Instance of '..instanceName..' must be a table, not '..type(instance))
                      end

****0                 local methodInstance = instance[methodName]
****0                 if methodInstance == nil then
****0                     error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                      end

                  else
                      -- for functions and classes
   32                 instanceName = name
   32                 instance = _G[instanceName]
                  end

   32             if instance == nil then
****0                 error( "No such name in global space: "..instanceName )
                  end

   32             if (type(instance) ~= 'table' and type(instance) ~= 'function') then
****0                 error( 'Name must match a function or a table: '..instanceName )
                  end

   32             table.insert( listOfNameAndInst, { name, instance } )
              end

    2         self:runSuiteByInstances( listOfNameAndInst )
          end

    4     function M.LuaUnit.run(...)
              -- Run some specific test classes.
              -- If no arguments are passed, run the class names specified on the
              -- command line. If no class name is specified on the command line
              -- run all classes whose name starts with 'Test'
              --
              -- If arguments are passed, they must be strings of the class names
              -- that you want to run or generic command line arguments (-o, -p, -v, ...)

    2         local runner = M.LuaUnit.new()
    2         return runner:runSuite(...)
          end

    4     function M.LuaUnit:runSuite( ... )

    2         local args = {...}
    2         if type(args[1]) == 'table' and args[1].__class__ == 'LuaUnit' then
                  -- run was called with the syntax M.LuaUnit:runSuite()
                  -- we support both M.LuaUnit.run() and M.LuaUnit:run()
                  -- strip out the first argument
****0             table.remove(args,1)
              end

    2         if #args == 0 then
    2             args = cmdline_argv
              end

    2         local options = pcall_or_abort( M.LuaUnit.parseCmdLine, args )

              -- We expect these option fields to be either `nil` or contain
              -- valid values, so it's safe to always copy them directly.
    2         self.verbosity     = options.verbosity
    2         self.quitOnError   = options.quitOnError
    2         self.quitOnFailure = options.quitOnFailure
    2         self.fname         = options.fname

    2         self.exeRepeat            = options.exeRepeat
    2         self.patternIncludeFilter = options.pattern
    2         self.shuffle              = options.shuffle

    2         if options.output then
****0             if options.output:lower() == 'junit' and options.fname == nil then
****0                 print('With junit output, a filename must be supplied with -n or --name')
****0                 os.exit(-1)
                  end
****0             pcall_or_abort(self.setOutputType, self, options.output)
              end

    2         self:runSuiteByNames( options.testNames or M.LuaUnit.collectTests() )

    2         return self.result.notPassedCount
          end
      -- class LuaUnit

      -- For compatbility with LuaUnit v2
    2 M.run = M.LuaUnit.run
    2 M.Run = M.LuaUnit.run

    4 function M:setVerbosity( verbosity )
****0     M.LuaUnit.verbosity = verbosity
      end
    2 M.set_verbosity = M.setVerbosity
    2 M.SetVerbosity = M.setVerbosity


    2 return M

==============================================================================
.\test\testHelper.lua
==============================================================================

    2 local M = {}

    2 M.old = io.read
    2 M.input = {}
    2 M.cnt = 0

      M.read = function()
   64     M.cnt = M.cnt+1
   64     return M.input[M.cnt]
      end

    2 return M



==============================================================================
.\test\unitTests.lua
==============================================================================


    2 lu = require "test.luaunit"

      --------------------- Cell unit tests -------------------------------

    2  local _ = require "test.cellUnitTest"

      ----------------- FrameMaker unit tests -----------------------------

    2 local _ = require "test.frameMakerUnitTest"

      ----------------- Frame unit tests ----------------------------------

    2 local _ = require "test.frameTest"

      ----------------- Execute tests -------------------------------------

    2 os.exit( lu.LuaUnit.run() )

==============================================================================
.\type\ChangeType.lua
==============================================================================

    2 local ChangeType = {
    2     DIE = "DIE",
    2     BIRTH = "BIRTH",
    2     NOTHING = "NOTHING"
      }

    2 return ChangeType

==============================================================================
.\type\StateType.lua
==============================================================================


    2 local StateType = {
    2     ALIVE = "ALIVE",
    2     DEAD = "DEAD"
      }

    2 return StateType

==============================================================================
main.lua
==============================================================================


      --local r = require "luacov"

    2 require "test.unitTests"

      --require("FrameMaker").getInstance().createFrame():simulate()

==============================================================================
Summary
==============================================================================

File                          Hits Missed Coverage
--------------------------------------------------
.\FrameMaker.lua              43   3      93.48%
.\entity\Cell.lua             32   0      100.00%
.\entity\Frame.lua            85   7      92.39%
.\input\FileInputHandler.lua  44   6      88.00%
.\test\cellUnitTest.lua       91   8      91.92%
.\test\frameMakerUnitTest.lua 26   0      100.00%
.\test\frameTest.lua          78   0      100.00%
.\test\luaunit.lua            559  796    41.25%
.\test\testHelper.lua         7    0      100.00%
.\test\unitTests.lua          5    0      100.00%
.\type\ChangeType.lua         5    0      100.00%
.\type\StateType.lua          4    0      100.00%
main.lua                      1    0      100.00%
--------------------------------------------------
Total                         980  820    54.44%
